VkPhysicalDevice                                            VkResult vkQueueSubmit(                                     Before an application can present an image, the imageâ€™s layout
  family {                                                      VkQueue              queue,                             must be transitioned to the VK_IMAGE_LAYOUT_PRESENT_SRC_KHR
    enum VkQueueFlagBits {                                      uint32_t             submitCount,                       layout, or for ashared presentable image the
      VK_QUEUE_GRAPHICS_BIT                                     const VkSubmitInfo*  pSubmits,                          VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR layout.
      VK_QUEUE_COMPUTE_BIT                                      VkFence              fence);
      VK_QUEUE_TRANSFER_BIT                                                                                             VkResult vkQueuePresentKHR(
      VK_QUEUE_SPARSE_BINDING_BIT                                                                                           VkQueue                  queue,
      VK_QUEUE_PROTECTED_BIT                                typedef struct VkSubmitInfo {                                   const VkPresentInfoKHR*  pPresentInfo);
      VK_QUEUE_VIDEO_DECODE_BIT_KHR                             VkStructureType              sType;
      VK_QUEUE_VIDEO_ENCODE_BIT_KHR                             const void*                  pNext;                     typedef struct VkPresentInfoKHR {
    }                                                           uint32_t                     waitSemaphoreCount;            VkStructureType        sType;
    queueCount                                                  const VkSemaphore*           pWaitSemaphores;               const void*            pNext;
    timestampBits                                               const VkPipelineStageFlags*  pWaitDstStageMask;             uint32_t               waitSemaphoreCount;
    minImageTransferGranularity                                 uint32_t                     commandBufferCount;            const VkSemaphore*     pWaitSemaphores;
  }[N]                                                          const VkCommandBuffer*       pCommandBuffers;               uint32_t               swapchainCount;
                                                                uint32_t                     signalSemaphoreCount;          const VkSwapchainKHR*  pSwapchains;
VkDevice                                                        const VkSemaphore*           pSignalSemaphores;             const uint32_t*        pImageIndices;
  family[M] { QueueCreateFlag, queue[..N}, priority }       } VkSubmitInfo;                                                 VkResult*              pResults;
                                                                                                                        } VkPresentInfoKHR;
VkQueue                                                     typedef enum VkSubmitFlagBitsKHR {
  enum VkDeviceQueueCreateFlagBits {                            VK_SUBMIT_PROTECTED_BIT_KHR
    VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT                    } VkSubmitFlagBitsKHR;
  }
  queue-family
  queue-index                                               typedef struct VkTimelineSemaphoreSubmitInfo {
  queue-priority                                                uint32_t           waitSemaphoreValueCount;
                                                                const uint64_t*    pWaitSemaphoreValues;
                                                                uint32_t           signalSemaphoreValueCount;
                                                                const uint64_t*    pSignalSemaphoreValues;
VkResult vkQueueWaitIdle(VkQueue queue);                    }


Before a fence or semaphore is signaled, it is guaranteed that any previously submitted queue operations have completed execution,
and that memory writes from those queue operations are available to future queue operations. Waiting on a signaled semaphore or
fence guarantees that previous writes that are available are also visible to subsequent commands.

