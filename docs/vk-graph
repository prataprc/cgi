VkMemoryHeap, VkMemoryType, VkRect2D, VkOffset2D, VkExtent2D, VkExtent3D

Instance, PhysicalDevice
========================

                                                                                                | vkEnumerateInstanceVersion                => Version
                                                                                                | vkEnumerateInstanceLayerProperties        => Vec<VkLayerProperties>
layer                                                                                           | vkEnumerateInstanceExtensionProperties    => Vec<VkExtensionProperties>

ApplicationInfo, layers, extensions                                                             | vkCreateInstance                          => VkInstance
VkInstance                                                                                      | vkEnumeratePhysicalDeviceGroups           => Vec<VkPhysicalDeviceGroupProperties>
VkInstance, name                                                                                | vkGetInstanceProcAddr                     => *func

VkInstance                                                                                      | vkEnumeratePhysicalDevices                => Vec<VkPhysicalDevice>
VkPhysicalDevice                                                                                | vkGetPhysicalDeviceProperties             => VkPhysicalDeviceProperties
VkPhysicalDevice                                                                                | vkGetPhysicalDeviceFeatures               => VkPhysicalDeviceFeatures
VkPhysicalDevice                                                                                | vkGetPhysicalDeviceMemoryProperties       => VkPhysicalDeviceMemoryProperties
VkPhysicalDevice                                                                                | vkEnumerateDeviceLayerProperties          => Vec<VkLayerProperties>
VkPhysicalDevice, layer                                                                         | vkEnumerateDeviceExtensionProperties      => Vec<VkExtensionProperties>
VkPhysicalDevice                                                                                | vkGetPhysicalDeviceQueueFamilyProperties  => Vec<VkQueueFamilyProperties>
VkPhysicalDevice                                                                                | vkGetPhysicalDeviceFormatProperties       => VkFormatProperties
VkPhysicalDevice, VkFormat, VkImageType, VkImageTiling, VkImageUsageFlag, VkImageCreateFlag     | vkGetPhysicalDeviceImageFormatProperties  => Vec<VkImageFormatProperties>
VkPhysicalDevice, VkSurface                                                                     | vkGetPhysicalDevicePresentRectanglesKHR   => Vec<VkRect2D>

typedef enum VkImageCreateFlag {                        typedef enum VkImageUsageFlag {                 typedef enum VkImageType {  typedef struct VkImageFormatProperties {
    VK_IMAGE_CREATE_SPARSE_BINDING_BIT,                     VK_IMAGE_USAGE_TRANSFER_SRC_BIT,                VK_IMAGE_TYPE_1D,           VkExtent3D            maxExtent;
    VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT,                   VK_IMAGE_USAGE_TRANSFER_DST_BIT,                VK_IMAGE_TYPE_2D,           uint32_t              maxMipLevels;
    VK_IMAGE_CREATE_SPARSE_ALIASED_BIT,                     VK_IMAGE_USAGE_SAMPLED_BIT,                     VK_IMAGE_TYPE_3D,           uint32_t              maxArrayLayers;
    VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT,                     VK_IMAGE_USAGE_STORAGE_BIT,                 }                               VkSampleCountFlags    sampleCounts;
    VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT,                    VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT,                                        VkDeviceSize          maxResourceSize;
    VK_IMAGE_CREATE_ALIAS_BIT,                              VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT,                            }
    VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT,        VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT,
    VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT,                VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT,
    VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT,    }
    VK_IMAGE_CREATE_EXTENDED_USAGE_BIT,                 typedef enum VkImageTiling {
    VK_IMAGE_CREATE_PROTECTED_BIT,                          VK_IMAGE_TILING_OPTIMAL,
    VK_IMAGE_CREATE_DISJOINT_BIT,                           VK_IMAGE_TILING_LINEAR,
}                                                       }


VkDevice, VkQueue
=================

VkPhysicalDevice, Vec<(qf, qc, qp)>, layers, extensions, VkPhysicalDeviceFeatures           | vkCreateDevice                        => VkDevice
VkDevice, qf, qi                                                                            | vkGetDeviceQueue                      => VkQueue
VkDevice                                                                                    | vkDeviceWaitIdle                      =>
VkDevice, timeout                                                                           | vkAcquireProfilingLockKHR             =>
VkDevice                                                                                    | vkReleaseProfilingLockKHR             =>
VkDevice, VkRenderPass                                                                      | vkGetRenderAreaGranularity            => VkExtent2D
VkDevice, VkSemaphore                                                                       | vkGetSemaphoreCounterValue            => uint64
VkDevice, VkQueryType, qc, VkQueryPipelineStatistic                                         | vkCreateQueryPool                     =>
VkDevice, VkQueryPool, (firstQ, count)                                                      | vkGetQueryPoolResults                 => pData
VkDevice, VkQueryPool, (firstQ, count)                                                      | vkResetQueryPool                      =>
VkQueue, Vec<VkSubmitInfo>, VkFence                                                         | vkQueueSubmit                         =>
VkQueue, Vec<VkPresentInfoKHR>                                                              | vkQueuePresentKHR                     =>

typedef struct VkSubmitInfo {                                   typedef enum VkPipelineStageFlag {
    uint32_t                       waitSemaphoreCount;              VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT,
    const VkSemaphore*             pWaitSemaphores;                 VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT,
    const VkPipelineStageFlag*     pWaitDstStageMask;               VK_PIPELINE_STAGE_VERTEX_INPUT_BIT,
    uint32_t                       commandBufferCount;              VK_PIPELINE_STAGE_VERTEX_SHADER_BIT,
    const VkCommandBuffer*         pCommandBuffers;                 VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT,
    uint32_t                       signalSemaphoreCount;            VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT,
    const VkSemaphore*             pSignalSemaphores;               VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT,
}                                                                   VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT,
                                                                    VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT,
typedef struct VkPresentInfoKHR {                                   VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT,
    uint32_t                 waitSemaphoreCount;                    VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT,
    const VkSemaphore*       pWaitSemaphores;                       VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,
    uint32_t                 swapchainCount;                        VK_PIPELINE_STAGE_TRANSFER_BIT,
    const VkSwapchainKHR*    pSwapchains;                           VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT,
    const uint32_t*          pImageIndices;                         VK_PIPELINE_STAGE_HOST_BIT,
    VkResult*                pResults;                              VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT,
}                                                               }


Memory and resources
====================


                CreateFlags UsageFlags Type Tiling Aspect Format Layout Extent samples miplevels arrlayers sharingMode queue
Image           o           o          o    o             o      o      o      o       o         o         o           o
ImageView                              o           o      o                            o         o
Buffer          o           o                                                                              o           o
BufferView                                                o


VkDevice  VkMemoryType, size                                                                | vkAllocateMemory                      => VkDeviceMemory
VkDevice, VkDeviceMemory                                                                    | vkGetDeviceMemoryOpaqueCaptureAddress => uint64
VkDevice, VkDeviceMemory                                                                    | vkFreeMemory                          =>

VkDevice, VkDeviceMemory, offset, size                                                      | vkMapMemory                           => void **
VkDevice, VkDeviceMemory                                                                    | vkUnmapMemory                         =>
VkDevice, Vec<(VkDeviceMemory, offset, size)>                                               | vkInvalidateMappedMemoryRanges        =>
VkDevice, Vec<(VkDeviceMemory, offset, size)>                                               | vkFlushMappedMemoryRanges             =>

VkDevice, VkBufferCreateFlag, size, VkBufferUsageFlag, VkSharingMode, queue-indexes         | vkCreateBuffer                        => VkBuffer
VkDevice, VkBuffer, VkFormat, offset, range                                                 | vkCreateBufferView                    => VkBufferView
VkDevice, VkBuffer, VkDeviceMemory, offset                                                  | vkBindBufferMemory                    =>
VkDevice, VkBuffer                                                                          | vkGetBufferMemoryRequirements         => (size, align, typ)
VkDevice, VkBuffer                                                                          | vkGetBufferDeviceAddress              => VkDeviceAddress
VkDevice, VkBuffer                                                                          | vkGetBufferOpaqueCaptureAddress       => uint64

typedef enum VkBufferCreateFlag {                           typedef enum VkBufferUsageFlag {
    VK_BUFFER_CREATE_SPARSE_BINDING_BIT,                        VK_BUFFER_USAGE_TRANSFER_SRC_BIT,
    VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT,                      VK_BUFFER_USAGE_TRANSFER_DST_BIT,
    VK_BUFFER_CREATE_SPARSE_ALIASED_BIT,                        VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT,
    VK_BUFFER_CREATE_PROTECTED_BIT,                             VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT,
    VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT,         VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT,
}                                                               VK_BUFFER_USAGE_STORAGE_BUFFER_BIT,
                                                                VK_BUFFER_USAGE_INDEX_BUFFER_BIT,
typedef enum VkSharingMode {                                    VK_BUFFER_USAGE_VERTEX_BUFFER_BIT,
    VK_SHARING_MODE_EXCLUSIVE,                                  VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT,
    VK_SHARING_MODE_CONCURRENT,                                 VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT,
}                                                           }


VkDevice, VkImageCreateInfo                                                                 | vkCreateImage                         => VkImage
VkDevice, VkImage, VkImageViewType, VkFormat, VkComponentMapping, VkImageSubresourceRange   | vkCreateImageView                     => VkImageView
VkDevice, VkImage, VkDeviceMemory, offset                                                   | vkBindImageMemory                     =>
VkDevice, VkImage                                                                           | vkGetImageMemoryRequirements          => (size, align, typ)
VkDevice, VkImage, VkImageSubresource                                                       | vkGetImageSubresourceLayout           => VkSubresourceLayout


typedef struct VkImageCreateInfo {                  typedef enum VkImageLayout {                                        typedef enum VkSampleCountFlag {
    VkImageCreateFlag   flags;                          VK_IMAGE_LAYOUT_UNDEFINED,                                          VK_SAMPLE_COUNT_1_BIT,
    VkImageType         imageType;                      VK_IMAGE_LAYOUT_GENERAL,                                            VK_SAMPLE_COUNT_2_BIT,
    VkFormat            format;                         VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL,                           VK_SAMPLE_COUNT_4_BIT,
    VkExtent3D          extent;                         VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL,                   VK_SAMPLE_COUNT_8_BIT,
    uint32_t            mipLevels;                      VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL,                    VK_SAMPLE_COUNT_16_BIT,
    uint32_t            arrayLayers;                    VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL,                           VK_SAMPLE_COUNT_32_BIT,
    VkSampleCountFlag   samples;                        VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,                               VK_SAMPLE_COUNT_64_BIT,
    VkImageTiling       tiling;                         VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,                           }
    VkImageUsageFlag    usage;                          VK_IMAGE_LAYOUT_PREINITIALIZED,                                 typedef enum VkImageAspectFlag {
    VkSharingMode       sharingMode;                    VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL,         VK_IMAGE_ASPECT_COLOR_BIT,
    uint32_t            queueFamilyIndexCount;          VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL,         VK_IMAGE_ASPECT_DEPTH_BIT,
    const uint32_t*     pQueueFamilyIndices;            VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL,                           VK_IMAGE_ASPECT_STENCIL_BIT,
    VkImageLayout       initialLayout;                  VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL,                            VK_IMAGE_ASPECT_METADATA_BIT,
}                                                       VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL,                         VK_IMAGE_ASPECT_PLANE_0_BIT,
                                                        VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL,                          VK_IMAGE_ASPECT_PLANE_1_BIT,
                                                        VK_IMAGE_LAYOUT_PRESENT_SRC_KHR,                                    VK_IMAGE_ASPECT_PLANE_2_BIT,
                                                    }                                                                   }

typedef enum VkImageViewType {          typedef struct VkComponentMapping {     typedef enum VkComponentSwizzle {       typedef struct VkImageSubresourceRange {
    VK_IMAGE_VIEW_TYPE_1D,                  VkComponentSwizzle r;                   VK_COMPONENT_SWIZZLE_IDENTITY,          VkImageAspectFlag     aspectMask;
    VK_IMAGE_VIEW_TYPE_2D,                  VkComponentSwizzle g;                   VK_COMPONENT_SWIZZLE_ZERO,              uint32_t              baseMipLevel;
    VK_IMAGE_VIEW_TYPE_3D,                  VkComponentSwizzle b;                   VK_COMPONENT_SWIZZLE_ONE,               uint32_t              levelCount;
    VK_IMAGE_VIEW_TYPE_CUBE,                VkComponentSwizzle a;                   VK_COMPONENT_SWIZZLE_R,                 uint32_t              baseArrayLayer;
    VK_IMAGE_VIEW_TYPE_1D_ARRAY,        }                                           VK_COMPONENT_SWIZZLE_G,                 uint32_t              layerCount;
    VK_IMAGE_VIEW_TYPE_2D_ARRAY,                                                    VK_COMPONENT_SWIZZLE_B,             }
    VK_IMAGE_VIEW_TYPE_CUBE_ARRAY,                                                  VK_COMPONENT_SWIZZLE_A,
}                                                                               }

typedef struct VkImageSubresource {     typedef struct VkSubresourceLayout {
    VkImageAspectFlag  aspectMask;          VkDeviceSize    offset;
    uint32_t           mipLevel;            VkDeviceSize    size;
    uint32_t           arrayLayer;          VkDeviceSize    rowPitch;
}                                           VkDeviceSize    arrayPitch;
                                            VkDeviceSize    depthPitch;
                                        }


Presentations
=============

VkPhysicalDevice, VkSurface                                                                 | vkGetPhysicalDeviceSurfaceCapabilitiesKHR     => VkSurfaceCapabilitiesKHR
VkPhysicalDevice, VkSurface                                                                 | vkGetPhysicalDeviceSurfaceFormatsKHR          => Vec<VkSurfaceFormatKHR>
VkPhysicalDevice, VkSurface                                                                 | vkGetPhysicalDeviceSurfacePresentModesKHR     => Vec<VkPresentModeKHR>
VkPhysicalDevice, VkSurface, qf                                                             | vkGetPhysicalDeviceSurfaceSupportKHR          => bool
VkDevice, VkSurface, VkSwapchainCreateInfoKHR                                               | vkCreateSwapchainKHR                          => VkSwapchain
VkDevice, VkSwapchain                                                                       | vkGetSwapchainImagesKHR                       => Vec<VkImage>
VkDevice, VkSwapchain, VkSemaphore, VkFence, timeout                                        | vkAcquireNextImageKHR                         => VkImage

VkDevice, VkFramebufferCreateFlag, VkRenderPass, Vec<VkImageView>, width, height, layers    | vkCreateFramebuffer                           => VkFrameBuffer


typedef struct VkSwapchainCreateInfoKHR {                   typedef enum VkPresentModeKHR {         typedef struct VkSurfaceFormatKHR {     typedef enum VkColorSpaceKHR {
    VkSwapchainCreateFlag            flags;                     VK_PRESENT_MODE_IMMEDIATE_KHR,          VkFormat           format;              VK_COLOR_SPACE_SRGB_NONLINEAR_KHR,
    VkSurfaceKHR                     surface;                   VK_PRESENT_MODE_MAILBOX_KHR,            VkColorSpaceKHR    colorSpace;      }
 +  uint32_t                         minImageCount;             VK_PRESENT_MODE_FIFO_KHR,           }
 +* VkFormat                         imageFormat;               VK_PRESENT_MODE_FIFO_RELAXED_KHR,
 +  VkColorSpaceKHR                  imageColorSpace;       }
 +* VkExtent2D                       imageExtent;           typedef enum VkFramebufferCreateFlag {
 +* uint32_t                         imageArrayLayers;          VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT = 0x00000001,
 +* VkImageUsageFlag                 imageUsage;            }
  * VkSharingMode                    imageSharingMode;      typedef enum VkSurfaceTransformFlag {                           typedef enum VkCompositeAlphaFlag {
  * uint32_t                         queueFamilyIndexCount;     VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR,                          VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR,
  * const uint32_t*                  pQueueFamilyIndices;       VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR,                         VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR,
 +  VkSurfaceTransformFlag           preTransform;              VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR,                        VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR,
 +  VkCompositeAlphaFlag             compositeAlpha;            VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR,                        VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR,
 +  VkPresentModeKHR                 presentMode;               VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR,             }
 +  VkBool32                         clipped;                   VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR,
    VkSwapchainKHR                   oldSwapchain;              VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR,
}                                                               VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR,
                                                                VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR,
                                                            }


Renderpass, Sampler
===================

VkDevice, VkSamplerCreateInfo                                                                               | vkCreateSampler               => VkSampler

typedef struct VkSamplerCreateInfo {                    typedef enum VkSamplerAddressMode {                 typedef enum VkCompareOp {
    VkSamplerCreateFlag     flags;                          VK_SAMPLER_ADDRESS_MODE_REPEAT,                     VK_COMPARE_OP_NEVER,
    VkFilter                magFilter;                      VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT,            VK_COMPARE_OP_LESS,
    VkFilter                minFilter;                      VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE,              VK_COMPARE_OP_EQUAL,
    VkSamplerMipmapMode     mipmapMode;                     VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER,            VK_COMPARE_OP_LESS_OR_EQUAL,
    VkSamplerAddressMode    addressModeU;                   VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE,       VK_COMPARE_OP_GREATER,
    VkSamplerAddressMode    addressModeV;               }                                                       VK_COMPARE_OP_NOT_EQUAL,
    VkSamplerAddressMode    addressModeW;                                                                       VK_COMPARE_OP_GREATER_OR_EQUAL,
    float                   mipLodBias;                 typedef enum VkSamplerMipmapMode {                      VK_COMPARE_OP_ALWAYS,
    VkBool32                anisotropyEnable;               VK_SAMPLER_MIPMAP_MODE_NEAREST,                 }
    float                   maxAnisotropy;                  VK_SAMPLER_MIPMAP_MODE_LINEAR,                  typedef enum VkBorderColor {
    VkBool32                compareEnable;              }                                                       VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK,
    VkCompareOp             compareOp;                  typedef enum VkFilter {                                 VK_BORDER_COLOR_INT_TRANSPARENT_BLACK,
    float                   minLod;                         VK_FILTER_NEAREST,                                  VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK,
    float                   maxLod;                         VK_FILTER_LINEAR,                                   VK_BORDER_COLOR_INT_OPAQUE_BLACK,
    VkBorderColor           borderColor;                }                                                       VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE,
    VkBool32                unnormalizedCoordinates;    typedef enum VkSamplerCreateFlag {                      VK_BORDER_COLOR_INT_OPAQUE_WHITE,
}                                                           VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT,           }
                                                            VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT,
                                                        }


VkDevice, VkRenderPassCreateInfo                                                                            | vkCreateRenderPass            => VkRenderPass


typedef struct VkRenderPassCreateInfo {                 typedef enum VkAttachmentDescriptionFlag {          typedef enum VkPipelineBindPoint {
  x VkRenderPassCreateFlags         flags;                 VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT,            VK_PIPELINE_BIND_POINT_GRAPHICS,
    uint32_t                        attachmentCount;    }                                                      VK_PIPELINE_BIND_POINT_COMPUTE,
    const VkAttachmentDescription*  pAttachments;       typedef enum VkAttachmentLoadOp {                   }
    uint32_t                        subpassCount;          VK_ATTACHMENT_LOAD_OP_LOAD,                      typedef struct VkAttachmentReference {
    const VkSubpassDescription*     pSubpasses;            VK_ATTACHMENT_LOAD_OP_CLEAR,                        uint32_t         attachment;
    uint32_t                        dependencyCount;       VK_ATTACHMENT_LOAD_OP_DONT_CARE,                    VkImageLayout    layout;
    const VkSubpassDependency*      pDependencies;      }                                                   }
}                                                       typedef enum VkAttachmentStoreOp {                  typedef enum VkDependencyFlags {
                                                           VK_ATTACHMENT_STORE_OP_STORE = 0,                   VK_DEPENDENCY_BY_REGION_BIT,
                                                           VK_ATTACHMENT_STORE_OP_DONT_CARE = 1,               VK_DEPENDENCY_DEVICE_GROUP_BIT,
                                                        }                                                      VK_DEPENDENCY_VIEW_LOCAL_BIT,
                                                                                                            }

typedef struct VkAttachmentDescription {        typedef struct VkSubpassDescription {                       typedef struct VkSubpassDependency {
    VkAttachmentDescriptionFlag flags;            x VkSubpassDescriptionFlags    flags;                         uint32_t                srcSubpass;
    VkFormat                    format;             VkPipelineBindPoint          pipelineBindPoint;             uint32_t                dstSubpass;
    VkSampleCountFlag           samples;            uint32_t                     inputAttachmentCount;          VkPipelineStageFlags    srcStageMask;
    VkAttachmentLoadOp          loadOp;             const VkAttachmentReference* pInputAttachments;             VkPipelineStageFlags    dstStageMask;
    VkAttachmentStoreOp         storeOp;            uint32_t                     colorAttachmentCount;          VkAccessFlags           srcAccessMask;
    VkAttachmentLoadOp          stencilLoadOp;      const VkAttachmentReference* pColorAttachments;             VkAccessFlags           dstAccessMask;
    VkAttachmentStoreOp         stencilStoreOp;     const VkAttachmentReference* pResolveAttachments;           VkDependencyFlags       dependencyFlags;
    VkImageLayout               initialLayout;      const VkAttachmentReference* pDepthStencilAttachment;   }
    VkImageLayout               finalLayout;        uint32_t                     preserveAttachmentCount;
}                                                   const uint32_t*              pPreserveAttachments;
                                                }

typedef enum VkAccessFlags {                        typedef enum VkPipelineStageFlags {
    VK_ACCESS_INDIRECT_COMMAND_READ_BIT,                VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT,
    VK_ACCESS_INDEX_READ_BIT,                           VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT,
    VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT,                VK_PIPELINE_STAGE_VERTEX_INPUT_BIT,
    VK_ACCESS_UNIFORM_READ_BIT,                         VK_PIPELINE_STAGE_VERTEX_SHADER_BIT,
    VK_ACCESS_INPUT_ATTACHMENT_READ_BIT,                VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT,
    VK_ACCESS_SHADER_READ_BIT,                          VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT,
    VK_ACCESS_SHADER_WRITE_BIT,                         VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT,
    VK_ACCESS_COLOR_ATTACHMENT_READ_BIT,                VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT,
    VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT,               VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT,
    VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT,        VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT,
    VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT,       VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT,
    VK_ACCESS_TRANSFER_READ_BIT,                        VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,
    VK_ACCESS_TRANSFER_WRITE_BIT,                       VK_PIPELINE_STAGE_TRANSFER_BIT,
    VK_ACCESS_HOST_READ_BIT,                            VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT,
    VK_ACCESS_HOST_WRITE_BIT,                           VK_PIPELINE_STAGE_HOST_BIT,
    VK_ACCESS_MEMORY_READ_BIT,                          VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT,
    VK_ACCESS_MEMORY_WRITE_BIT,                         VK_PIPELINE_STAGE_ALL_COMMANDS_BIT,
    VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR,  }
    VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR,
    VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR,
    VK_ACCESS_NONE_KHR,
}


DescriptorSets
==============

pData - VkDescriptorImageInfo, VkDescriptorBufferInfo, or VkBufferView

VkDevice, VkDescriptorPoolCreateFlags, maxSets, Vec<(VkDescriptorType, count)>                  | vkCreateDescriptorPool                => VkDescriptorPool
VkDevice, VkDescriptorPool                                                                      | vkResetDescriptorPool                 =>
VkDevice, VkDescriptorSetLayoutCreateFlags, Vec<VkDescriptorSetLayoutBinding>                   | vkGetDescriptorSetLayoutSupport       => VkBool32
VkDevice, VkDescriptorSetLayoutCreateFlags, Vec<VkDescriptorSetLayoutBinding>                   | vkCreateDescriptorSetLayout           => VkDescriptorSetLayout
VkDevice, VkDescriptorPool, Vec<VkDescriptorSetLayout>                                          | vkAllocateDescriptorSets              => Vec<VkDescriptorSet>
VkDevice, Vec<VkWriteDescriptorSet>, Vec<VkCopyDescriptorSet>                                   | vkUpdateDescriptorSets                =>
VkDevice, VkDescriptorUpdateTemplateCreateInfo                                                  | vkCreateDescriptorUpdateTemplate      => VkDescriptorUpdateTemplate
VkDevice, VkDescriptorSet, VkDescriptorUpdateTemplate, pData                                    | vkUpdateDescriptorSetWithTemplate     =>
VkDevice, VkDescriptorPool, Vec<VkDescriptorSet>                                                | vkFreeDescriptorSets

typedef enum VkDescriptorPoolCreateFlags {                              typedef enum VkDescriptorType {                     typedef enum VkShaderStageFlags {
    VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT,                      VK_DESCRIPTOR_TYPE_SAMPLER,                         VK_SHADER_STAGE_VERTEX_BIT,
    VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT,                        VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,          VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT,
}                                                                           VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,                   VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT,
typedef struct VkDescriptorSetLayoutBinding {                               VK_DESCRIPTOR_TYPE_STORAGE_IMAGE,                   VK_SHADER_STAGE_GEOMETRY_BIT,
    uint32_t              binding;                                          VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER,            VK_SHADER_STAGE_FRAGMENT_BIT,
    VkDescriptorType      descriptorType;                                   VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER,            VK_SHADER_STAGE_COMPUTE_BIT,
    uint32_t              descriptorCount;                                  VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,                  VK_SHADER_STAGE_ALL_GRAPHICS,
    VkShaderStageFlags    stageFlags;                                       VK_DESCRIPTOR_TYPE_STORAGE_BUFFER,                  VK_SHADER_STAGE_ALL,
    const VkSampler*      pImmutableSamplers;                               VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC,      }
}                                                                           VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC,
typedef enum VkDescriptorSetLayoutCreateFlags {                             VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT,
    VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT,         }
    VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR,
}

typedef struct VkCopyDescriptorSet {        typedef struct VkWriteDescriptorSet {                       typedef struct VkDescriptorImageInfo {
    VkDescriptorSet    srcSet;                  VkDescriptorSet                  dstSet;                    VkSampler        sampler;
    uint32_t           srcBinding;              uint32_t                         dstBinding;                VkImageView      imageView;
    uint32_t           srcArrayElement;         uint32_t                         dstArrayElement;           VkImageLayout    imageLayout;
    VkDescriptorSet    dstSet;                  uint32_t                         descriptorCount;       }
    uint32_t           dstBinding;              VkDescriptorType                 descriptorType;        typedef struct VkDescriptorBufferInfo {
    uint32_t           dstArrayElement;         const VkDescriptorImageInfo*     pImageInfo;                VkBuffer        buffer;
    uint32_t           descriptorCount;         const VkDescriptorBufferInfo*    pBufferInfo;               VkDeviceSize    offset;
}                                               const VkBufferView*              pTexelBufferView;          VkDeviceSize    range;
                                            }                                                           }

typedef struct VkDescriptorUpdateTemplateCreateInfo {                       typedef enum VkDescriptorUpdateTemplateType {               typedef struct VkDescriptorUpdateTemplateEntry {
  x VkDescriptorUpdateTemplateCreateFlags     flags;                            VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET,          uint32_t            dstBinding;
    uint32_t                                  descriptorUpdateEntryCount;       VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR,    uint32_t            dstArrayElement;
    const VkDescriptorUpdateTemplateEntry*    pDescriptorUpdateEntries;     }                                                               uint32_t            descriptorCount;
    VkDescriptorUpdateTemplateType            templateType;                                                                                 VkDescriptorType    descriptorType;
    VkDescriptorSetLayout                     descriptorSetLayout;                                                                          size_t              offset;
    VkPipelineBindPoint                       pipelineBindPoint;                                                                            size_t              stride;
    VkPipelineLayout                          pipelineLayout;                                                                           }
    uint32_t                                  set;
}


Pipelines
=========

VkDevice, pCode                                                                                                 | vkCreateShaderModule          => VkShaderModule
VkDevice, VkPipelineCacheCreateFlags, pInitialData                                                              | vkCreatePipelineCache         => VkPipelineCache
VkDevice, VkPipelineCache                                                                                       | vkGetPipelineCacheData        => pData
VkDevice, VkPipelineCache, Vec<VkPipelineCache>                                                                 | vkMergePipelineCaches         =>
VkDevice, Vec<VkDescriptorSetLayout>, Vec<VkPushConstantRange>                                                  | vkCreatePipelineLayout        => VkPipelineLayout

VkDevice, VkPipelineCache, Vec<VkComputePipelineCreateInfo>                                                     | vkCreateComputePipelines      => Vec<VkPipeline>

typedef struct VkComputePipelineCreateInfo {                    typedef enum VkPipelineCreateFlags {
    VkPipelineCreateFlags              flags;                       VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT,
    VkPipelineShaderStageCreateInfo    stage;                       VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT,
    VkPipelineLayout                   layout;                      VK_PIPELINE_CREATE_DERIVATIVE_BIT,
    VkPipeline                         basePipelineHandle;          VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT,
    int32_t                            basePipelineIndex;           VK_PIPELINE_CREATE_DISPATCH_BASE_BIT,
}                                                                   VK_PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR,
                                                                    VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR,
                                                                    VK_PIPELINE_CREATE_LIBRARY_BIT_KHR,
                                                                }

typedef struct VkPipelineShaderStageCreateInfo {                typedef struct VkSpecializationInfo {                   typedef struct VkSpecializationMapEntry {
  x VkPipelineShaderStageCreateFlags    flags;                      uint32_t                           mapEntryCount;       uint32_t    constantID;
    VkShaderStageFlags                  stage;                      const VkSpecializationMapEntry*    pMapEntries;         uint32_t    offset;
    VkShaderModule                      module;                     size_t                             dataSize;            size_t      size;
    const char*                         pName;                      const void*                        pData;           }
    const VkSpecializationInfo*         pSpecializationInfo;    }
}


vkCreateGraphicsPipelines

Synchronisation
===============

vkCreateSemaphore
vkSignalSemaphore
vkWaitSemaphores
vkWaitSemaphoresKHR
vkCreateEvent
vkGetEventStatus
vkResetEvent
vkSetEvent
vkCreateFence
vkGetFenceFdKHR
vkGetFenceStatus
vkResetFences
vkWaitForFences

CommandBuffer
=============

+-------+                       +---------+
| State |                       | Execute |
+-------+                       +---------+

* bind-point-VkDescriptorSet    * Set, Bind, Push
* compute-pipeline              * Copy, Fill, Update, Clear, Blit
* graphics-pipeline             * Draw, Resolve
  * Index-buffer                * Dispatch
  * Vertex-buffers              * Query
                                * PipelineBarrier, Event


VkDevice, queue-family                                        | vkCreateCommandPool           VkCommandPool
VkDevice, VkCommandPool                                       | vkResetCommandPool
VkDevice, VkCommandPool                                       | vkTrimCommandPool

VkDevice, VkCommandPool                                       | vkAllocateCommandBuffers      Vec<VkCommandBuffer>
VkCommandBuffer, [VkRenderPass, subpass], [VkFramebuffer]     | vkBeginCommandBuffer
VkCommandBuffer, VkQueryPool                                  | vkCmdBeginQuery
VkCommandBuffer, VkRenderPass, VkFramebuffer                  | vkCmdBeginRenderPass
VkCommandBuffer                                               | vkCmdSetBlendConstants
VkCommandBuffer                                               | vkCmdSetDepthBias
VkCommandBuffer                                               | vkCmdSetDepthBounds
VkCommandBuffer                                               | vkCmdSetDeviceMask
VkCommandBuffer                                               | vkCmdSetLineWidth
VkCommandBuffer                                               | vkCmdSetScissor
VkCommandBuffer                                               | vkCmdSetStencilCompareMask
VkCommandBuffer                                               | vkCmdSetStencilReference
VkCommandBuffer                                               | vkCmdSetStencilWriteMask
VkCommandBuffer                                               | vkCmdSetViewport
VkCommandBuffer, VkPipelineLayout, Vec<VkDescriptorSet>       | vkCmdBindDescriptorSets
VkCommandBuffer, VkPipeline                                   | vkCmdBindPipeline
VkCommandBuffer, VkBuffer                                     | vkCmdBindIndexBuffer
VkCommandBuffer, Vec<VkBuffer>                                | vkCmdBindVertexBuffers
VkCommandBuffer, VkImage, VkImage                             | vkCmdBlitImage
VkCommandBuffer, Vec<VkClearAttachment>, Vec<VkClearRect>     | vkCmdClearAttachments
VkCommandBuffer, VkImage                                      | vkCmdClearColorImage
VkCommandBuffer, VkImage                                      | vkCmdClearDepthStencilImage
VkCommandBuffer, VkBuffer                                     | vkCmdFillBuffer
VkCommandBuffer, VkBuffer                                     | vkCmdUpdateBuffer
VkCommandBuffer, VkBuffer, VkBuffer                           | vkCmdCopyBuffer
VkCommandBuffer, VkBuffer, VkImage                            | vkCmdCopyBufferToImage
VkCommandBuffer, VkImage, VkImage                             | vkCmdCopyImage
VkCommandBuffer, VkImage, VkBuffer                            | vkCmdCopyImageToBuffer
VkCommandBuffer, VkQueryPool, VkBuffer                        | vkCmdCopyQueryPoolResults
VkCommandBuffer, VkQueryPool                                  | vkCmdResetQueryPool
VkCommandBuffer, VkQueryPool                                  | vkCmdWriteTimestamp
VkCommandBuffer, VkQueryPool                                  | vkCmdEndQuery
VkCommandBuffer                                               | vkCmdDraw
VkCommandBuffer                                               | vkCmdDrawIndexed
VkCommandBuffer, VkBuffer                                     | vkCmdDrawIndexedIndirect
VkCommandBuffer, VkBuffer, VkBuffer                           | vkCmdDrawIndexedIndirectCount
VkCommandBuffer, VkBuffer                                     | vkCmdDrawIndirect
VkCommandBuffer, VkBuffer, VkBuffer                           | vkCmdDrawIndirectCount
VkCommandBuffer                                               | vkCmdEndRenderPass
VkCommandBuffer, Vec<VkCommandBuffer>                         | vkCmdExecuteCommands
VkCommandBuffer                                               | vkCmdNextSubpass
VkCommandBuffer                                               | vkCmdPipelineBarrier
VkCommandBuffer, VkPipelineLayout                             | vkCmdPushConstants
VkCommandBuffer, VkPipelineLayout, VkDescriptorSet            | vkCmdPushDescriptorSetKHR
VkCommandBuffer, VkDescriptorUpdateTemplate, VkPipelineLayout | vkCmdPushDescriptorSetWithTemplateKHR
VkCommandBuffer, VkEvent                                      | vkCmdResetEvent
VkCommandBuffer, VkEvent                                      | vkCmdSetEvent
VkCommandBuffer, VkEvent                                      | vkCmdWaitEvents
VkCommandBuffer, VkImage, VkImage                             | vkCmdResolveImage
VkCommandBuffer                                               | vkEndCommandBuffer
VkCommandBuffer                                               | vkResetCommandBuffer
VkDevice, VkCommandPool, Vec<VkCommandBuffer>                 | vkFreeCommandBuffers

------------------

vkDestroyBuffer
vkDestroyBufferView
vkDestroyCommandPool
vkDestroyDescriptorPool
vkDestroyDescriptorSetLayout
vkDestroyDescriptorUpdateTemplate
vkDestroyDescriptorUpdateTemplateKHR
vkDestroyDevice
vkDestroyEvent
vkDestroyFence
vkDestroyFramebuffer
vkDestroyImage
vkDestroyImageView
vkDestroyInstance
vkDestroyPipeline
vkDestroyPipelineCache
vkDestroyPipelineLayout
vkDestroyQueryPool
vkDestroyRenderPass
vkDestroySampler
vkDestroySemaphore
vkDestroyShaderModule
vkDestroySurfaceKHR
vkDestroySwapchainKHR

vkCreateDeferredOperationKHR
vkDeferredOperationJoinKHR
vkDestroyDeferredOperationKHR
vkGetDeferredOperationMaxConcurrencyKHR
vkGetDeferredOperationResultKHR
