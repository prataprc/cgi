TODO: vet all the APIs and data-structures associated with dispatchable and non-dispatchable handles.

typedef uint64_t VkDeviceSize;
typedef uint64_t VkDeviceAddress;
VkExtent2D VkExtent3D { width, height, depth }
VkOffset2D VkOffset3D { x, y, z }
VkRect2D { VkOffset2D, VkExtent2D }

Size:
    VkMemoryHeap -> size
    VkDeviceMemory -> alloc_size
    VkBuffer -> buffer_size
    VkImageFormatProperties -> max_resource_size
    VkSubresourceLayout -> (offset, size, row_pitch, array_pitch, depth_pitch)
    VkDescriptorBufferInfo -> (offset, size)
    VkDescriptorUpdateTemplate -> (offset, size)
    VkSpecializationInfo -> data_size
    VkSpecializationMapEntry -> (offset, entry_size)
    vkMapMemory(.., offset, size)
    vkInvalidateMappedMemoryRanges(.., offset, size)
    vkFlushMappedMemoryRanges(.., offset, size)
    vkCmdBindIndexBuffer(.., size)
    vkCmdPushConstants(.., size)
Extent: (is in texels ?)
    VkImageFormatProperties -> max_extent
    VkQueueFamilyProperties -> minImageTransferGranularity
    VkImageCreateInfo -> extent
    VkSurfaceCapabilitiesKHR -> current_extent, min_extent, max_extent
    VkSwapchainCreateInfoKHR -> image_extent

Fragment:
    composed-of -> raster-position, color, texture-coordinates, depth, alpha, stencil, scissor, window-id
    ops -> discard-rectangle, scissor, exclusive-scissor, sample-mask, fragment-shading, multisample-coverage, depth-bounds,
           stencil, depth, representative-fragment, sample-couting, coverage-to-color, coverage-reduction, coverage-modulation

VkFormat:
    RGBA/E/DS/X
    UNORM/SNORM/USCALED/SSCALED/UINT/SINT/UFLOAT/SFLOAT
    PACK8/PACK16/2PACK16/3PACK16/4PACK16/PACK32/BLOCK
    BC1/BC2/BC3/BC4/BC5/BC6H/BC7/ETC2/EAC/ASTC/PVRTC1/PVRTC2
    2BPP/4BPP/SRGB, 2PLANE/3PLANE, 422/420/444

Image
    ImageType -> 1D, 2D, 3D
    ImageTiling -> Linear, Optimal
    ImageDimensions -> {w, array_layers}, {w, h, array_layers}, {w, h, d }
    ImageAspects -> Color, Depth, Stencil, Metadata, Plane0, Plane1, Plane2, MemoryPlane0, MemoryPlane1, MemoryPlane2,
    ImageUsage -> tx_source, tx_dest, sampled, storage, color_attach, depth_stencil_attach, transient_attch, input_attach
    ImageCreate ->
    Format -> Size, DataType, Plane, Block, Aspects, Properties(Phydev)
    ImageFormatProperties -> max_extent, max_mip_levels, max_array_layers, sample_counts, max_resource_size
    ImageLayout -> undefined, general, preinitialized
                   tx_src_optimal, tx_dst_optimal,
                   attach_optimal, ro_optimal, color_attach_optimal, depth_attach_optimal, stencil_attach_optimal, depth_ro_optimal, stencil_ro_optimal,
                   depth_stencil_attach_optimal, depth_stencil_ro_optimal, depth_ro_stencil_attach_optimal, depth_attach_stencil_ro_optimal,
                   video_encode_src, video_encode_dst, video_encode_dpb, video_decode_src, video_decode_dst, video_decode_dpb,
                   shader_ro_optimal, present_src, shared_present,

Family of types: `Vk*CreateInfo`, `Vk*Flags`, `Vk*FlagBit`,

Family of functions: `vkQueue*`, `vkCreate*`, `vkAllocate*`, `vkDestroy*`, `vkFree*` `vkGet*`, `vkEnumerate*`, `vkCmd*`


Dispatchable and Non-Dispatchable Handles
-----------------------------------------

There is no global state in vulkan, all states are captured within dispatchable handles (aka objects).

VkInstance
    +-> VkPhysicalDevice
    |   +-> VkDevice <- VkDeviceCreateInfo
    |       +-> VkQueue
    |       +-> VkSwapchain <- VkSwapchainCreateInfoKHR
    |       +-> VkCommandPool <- VkCommandPoolCreateInfo
    |       +-> VkCommandBuffer <- VkCommandBufferAllocateInfo
    |       +-> VkDeviceMemory <- VkMemoryAllocateInfo
    |       +-> VkBuffer <- VkBufferCreateInfo
    |       +-> VkBufferView <- VkBufferViewCreateInfo
    |       +-> VkImage <- VkImageCreateInfo
    |       +-> VkImageView <- VkImageViewCreateInfo
    |       +-> VkSampler <- VkSamplerCreateInfo
    |       +-> VkQueryPool <- VkQueryPoolCreateInfo
    |       +-> VkShaderModule <- VkShaderModuleCreateInfo
    |       +-> VkPipeline <- VkPipelineCache, VkGraphicsPipelineCreateInfo
    |       +-> VkPipeline <- VkPipelineCache, VkComputePipelineCreateInfo
    |       +-> VkPipelineLayout <- VkPipelineLayoutCreateInfo
    |       +-> VkPipelineCache <- VkPipelineCacheCreateInfo
    |       +-> VkEvent <- VkEventCreateInfo
    |       +-> VkFence <- VkFenceCreateInfo
    |       +-> VkSemaphore <- VkSemaphoreCreateInfo
    |       +-> VkRenderPass <- VkRenderPassCreateInfo
    |       +-> VkFramebuffer <- VkFramebufferCreateInfo
    |       +-> VkDescriptorPool <- VkDescriptorPoolCreateInfo
    |       +-> VkDescriptorSet <- VkDescriptorSetAllocateInfo
    |       +-> VkDescriptorSetLayout <- VkDescriptorSetLayoutCreateInfo
    |       +-> VkDescriptorUpdateTemplate <- VkDescriptorUpdateTemplateCreateInfo
    +-> VkSurface
    +-> VkDisplay
    +-> VkDisplayMode


Instance
========

===>                                                                                                 | vkEnumerateInstanceVersion                => Version
===>                                                                                                 | vkEnumerateInstanceLayerProperties        => Vec<VkLayerProperties>
===> layer                                                                                           | vkEnumerateInstanceExtensionProperties    => Vec<VkExtensionProperties>

===> ApplicationInfo, layers, extensions                                                             | vkCreateInstance                          => VkInstance
===> VkInstance                                                                                      | vkEnumeratePhysicalDeviceGroups           => Vec<VkPhysicalDeviceGroupProperties>
===> VkInstance, name                                                                                | vkGetInstanceProcAddr                     => *func
===> VkInstance                                                                                      | vkDestroyInstance                         =>

===> VkInstance, VkDebugReportFlags, pfnCallbak, pUserData                                           | vkCreateDebugReportCallbackEXT            => VkDebugReportCallbackEXT
===> VkInstance, VkDebugReportFlags, VkDebugReportObjectTypeEXT,  obj, loc, msgCode, layer, message  | vkDebugReportMessageEXT                   =>
===> VkInstance, VkDebugReportCallbackEXT                                                            | vkDestroyDebugReportCallbackEXT           =>

===> VkInstance, VkDebugUtilsMessengerCreateInfoEXT                                                  | vkCreateDebugUtilsMessengerEXT            => VkDebugUtilsMessengerEXT
===> VkInstance, VkDebugUtilsMessageSeverityFlags VkDebugUtilsMessageTypeFlags, pCallbackData        | vkSubmitDebugUtilsMessageEXT              =>
===> VkInstance, VkDebugUtilsMessengerEXT                                                            | vkDestroyDebugUtilsMessengerEXT           =>


typedef enum VkDebugReportFlags {                   typedef enum VkDebugReportFlags {
    VK_DEBUG_REPORT_INFORMATION_BIT_EXT,                VK_DEBUG_REPORT_INFORMATION_BIT_EXT,
    VK_DEBUG_REPORT_WARNING_BIT_EXT,                    VK_DEBUG_REPORT_WARNING_BIT_EXT,
    VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT,        VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT,
    VK_DEBUG_REPORT_ERROR_BIT_EXT,                      VK_DEBUG_REPORT_ERROR_BIT_EXT,
    VK_DEBUG_REPORT_DEBUG_BIT_EXT,                      VK_DEBUG_REPORT_DEBUG_BIT_EXT,
}                                                   }

typedef struct VkDebugUtilsMessengerCreateInfoEXT {             typedef enum VkDebugUtilsMessageSeverityFlags {         typedef enum VkDebugUtilsMessageTypeFlags {
  x VkDebugUtilsMessengerCreateFlags        flags;                  VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT,        VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT,
    VkDebugUtilsMessageSeverityFlags        messageSeverity;        VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT,           VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT,
    VkDebugUtilsMessageTypeFlagsEXT         messageType;            VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT,        VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT,
    PFN_vkDebugUtilsMessengerCallbackEXT    pfnUserCallback;        VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT,      }
    void*                                   pUserData;          }
}

List of surface creating APIs

    vkCreate {
        DisplayPlaneSurfaceKHR      HeadlessSurfaceEXT          WaylandSurfaceKHR           MacOSSurfaceMVK         DirectFBSurfaceEXT
                                                                Win32SurfaceKHR             MetalSurfaceEXT         ImagePipeSurfaceFUCHSIA
        StreamDescriptorSurfaceGGP                              XcbSurfaceKHR                                       AndroidSurfaceKHR
        ViSurfaceNN                                             XlibSurfaceKHR                                      IOSSurfaceMVK
                                                                                                                    ScreenSurfaceQNX
    }
    vkDestroySurfaceKHR


PhysicalDevice
==============

===> VkInstance                                                                                      | vkEnumeratePhysicalDevices                => Vec<VkPhysicalDevice>
===> VkPhysicalDevice                                                                                | vkGetPhysicalDeviceProperties             => VkPhysicalDeviceProperties
===> VkPhysicalDevice                                                                                | vkGetPhysicalDeviceFeatures               => VkPhysicalDeviceFeatures
===> VkPhysicalDevice                                                                                | vkGetPhysicalDeviceMemoryProperties       => VkPhysicalDeviceMemoryProperties
===> VkPhysicalDevice                                                                                | vkEnumerateDeviceLayerProperties          => Vec<VkLayerProperties>
===> VkPhysicalDevice, layer                                                                         | vkEnumerateDeviceExtensionProperties      => Vec<VkExtensionProperties>
===> VkPhysicalDevice                                                                                | vkGetPhysicalDeviceQueueFamilyProperties  => Vec<VkQueueFamilyProperties>
===> VkPhysicalDevice, VkFormat                                                                      | vkGetPhysicalDeviceFormatProperties       => VkFormatProperties
===> VkPhysicalDevice, VkFormat, VkImageType, VkImageTiling, VkImageUsageFlags, VkImageCreateFlag    | vkGetPhysicalDeviceImageFormatProperties  => Vec<VkImageFormatProperties>
===> VkPhysicalDevice, VkSurface                                                                     | vkGetPhysicalDevicePresentRectanglesKHR   => Vec<VkRect2D>

typedef enum VkImageCreateFlag {                        typedef enum VkImageUsageFlags {                typedef enum VkImageType {  typedef struct VkImageFormatProperties {
    VK_IMAGE_CREATE_SPARSE_BINDING_BIT,                     VK_IMAGE_USAGE_TRANSFER_SRC_BIT,                VK_IMAGE_TYPE_1D,           VkExtent3D            maxExtent;
    VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT,                   VK_IMAGE_USAGE_TRANSFER_DST_BIT,                VK_IMAGE_TYPE_2D,           uint32_t              maxMipLevels;
    VK_IMAGE_CREATE_SPARSE_ALIASED_BIT,                     VK_IMAGE_USAGE_SAMPLED_BIT,                     VK_IMAGE_TYPE_3D,           uint32_t              maxArrayLayers;
    VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT,                     VK_IMAGE_USAGE_STORAGE_BIT,                 }                               VkSampleCountFlags    sampleCounts;
    VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT,                    VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT,                                        VkDeviceSize          maxResourceSize;
    VK_IMAGE_CREATE_ALIAS_BIT,                              VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT,                            }
    VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT,        VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT,    typedef enum VkPhysicalDeviceType {
    VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT,                VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT,            VK_PHYSICAL_DEVICE_TYPE_OTHER,
    VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT,    }                                                   VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU,
    VK_IMAGE_CREATE_EXTENDED_USAGE_BIT,                 typedef enum VkImageTiling {                        VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU,
    VK_IMAGE_CREATE_PROTECTED_BIT,                          VK_IMAGE_TILING_OPTIMAL,                        VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU,
    VK_IMAGE_CREATE_DISJOINT_BIT,                           VK_IMAGE_TILING_LINEAR,                         VK_PHYSICAL_DEVICE_TYPE_CPU,
}                                                       }                                               }

typedef struct VkFormatProperties {                     typedef struct VkMemoryType {                   typedef enum VkMemoryPropertyFlags {
    VkFormatFeatureFlags    linearTilingFeatures;           VkMemoryPropertyFlags    propertyFlags;         VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT,
    VkFormatFeatureFlags    optimalTilingFeatures;          uint32_t                 heapIndex;             VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT,
    VkFormatFeatureFlags    bufferFeatures;             }                                                   VK_MEMORY_PROPERTY_HOST_COHERENT_BIT,
} VkFormatProperties;                                                                                       VK_MEMORY_PROPERTY_HOST_CACHED_BIT,
                                                        typedef struct VkMemoryHeap {                       VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT,
typedef enum VkMemoryHeapFlags {                            VkDeviceSize         size;                      VK_MEMORY_PROPERTY_PROTECTED_BIT,
    VK_MEMORY_HEAP_DEVICE_LOCAL_BIT,                        VkMemoryHeapFlags    flags;                     VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD,
    VK_MEMORY_HEAP_MULTI_INSTANCE_BIT,                  }                                                   VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD,
}                                                                                                       }

typedef enum VkFormatFeatureFlags {                             typedef struct VkQueueFamilyProperties {
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT,                            VkQueueFlagBits queueFlags;
    VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT,                            uint32_t        queueCount;
    VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT,                     uint32_t        timestampValidBits;
    VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT,                     VkExtent3D      minImageTransferGranularity;
    VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT,                 }
    VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT,          typedef enum VkQueueFlagBits {
    VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT,                            VK_QUEUE_GRAPHICS_BIT = 0x00000001,
    VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT,                         VK_QUEUE_COMPUTE_BIT = 0x00000002,
    VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT,                   VK_QUEUE_TRANSFER_BIT = 0x00000004,
    VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT,                 VK_QUEUE_SPARSE_BINDING_BIT = 0x00000008,
    VK_FORMAT_FEATURE_BLIT_SRC_BIT,                                 VK_QUEUE_PROTECTED_BIT = 0x00000010,
    VK_FORMAT_FEATURE_BLIT_DST_BIT,                             }
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT,
    VK_FORMAT_FEATURE_TRANSFER_SRC_BIT,
    VK_FORMAT_FEATURE_TRANSFER_DST_BIT,
    VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT,
    VK_FORMAT_FEATURE_DISJOINT_BIT,
    VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT,
}


VkDevice, VkQueue, VkQueryPool
==============================

===> VkPhysicalDevice, Vec<(qf, qc, qp)>, layers, extensions, VkPhysicalDeviceFeatures           | vkCreateDevice                        => VkDevice
===> VkDevice, qf, qi                                                                            | vkGetDeviceQueue                      => VkQueue
===> VkDevice                                                                                    | vkDeviceWaitIdle                      =>

===> VkDevice, timeout                                                                           | vkAcquireProfilingLockKHR             =>
===> VkDevice                                                                                    | vkReleaseProfilingLockKHR             =>

===> VkDevice, VkRenderPass                                                                      | vkGetRenderAreaGranularity            => VkExtent2D
===> VkDevice, VkSemaphore                                                                       | vkGetSemaphoreCounterValue            => uint64

===> VkDevice, VkQueryType, qc, VkQueryPipelineStatistic                                         | vkCreateQueryPool                     => VkQueryPool
===> VkDevice, VkQueryPool, (firstQ, count)                                                      | vkGetQueryPoolResults                 => pData
===> VkDevice, VkQueryPool, (firstQ, count)                                                      | vkResetQueryPool                      =>

===> VkQueue, Vec<VkSubmitInfo>, VkFence                                                         | vkQueueSubmit                         =>
===> VkQueue, Vec<VkPresentInfoKHR>                                                              | vkQueuePresentKHR                     =>
===> VkQueue                                                                                     | vkQueueWaitIdle                       =>


typedef struct VkSubmitInfo {                                   typedef enum VkPipelineStageFlags {                         typedef enum VkDeviceEventTypeEXT {
    uint32_t                       waitSemaphoreCount;              VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT,                          VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT,
    const VkSemaphore*             pWaitSemaphores;                 VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT,                    }
    const VkPipelineStageFlags*    pWaitDstStageMask;               VK_PIPELINE_STAGE_VERTEX_INPUT_BIT,
    uint32_t                       commandBufferCount;              VK_PIPELINE_STAGE_VERTEX_SHADER_BIT,                    typedef enum VkDisplayEventTypeEXT {
    const VkCommandBuffer*         pCommandBuffers;                 VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT,          VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT,
    uint32_t                       signalSemaphoreCount;            VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT,   }
    const VkSemaphore*             pSignalSemaphores;               VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT,
}                                                                   VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT,
                                                                    VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT,
typedef struct VkPresentInfoKHR {                                   VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT,
    uint32_t                 waitSemaphoreCount;                    VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT,
    const VkSemaphore*       pWaitSemaphores;                       VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,
    uint32_t                 swapchainCount;                        VK_PIPELINE_STAGE_TRANSFER_BIT,
    const VkSwapchainKHR*    pSwapchains;                           VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT,
    const uint32_t*          pImageIndices;                         VK_PIPELINE_STAGE_HOST_BIT,
    VkResult*                pResults;                              VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT,
}                                                               }


Memory and resources
====================


                CreateFlags UsageFlags Type Tiling Aspect Format Layout Extent samples miplevels arrlayers sharingMode queue size
Image           o           o          o    o             o      o      o      o       o         o         o           o
ImageView                              o           o      o                            o         o
Surface                     o          2D   Linear RGBA   S             S      1       1         S         o           o
Buffer          o           o                                                                              o           o     o
BufferView                                                o


===> VkDevice  VkMemoryType, size                                                                | vkAllocateMemory                      => VkDeviceMemory
===> VkDevice, VkDeviceMemory                                                                    | vkGetDeviceMemoryOpaqueCaptureAddress => uint64
===> VkDevice, VkDeviceMemory                                                                    | vkFreeMemory                          =>

===> VkDevice, VkDeviceMemory, offset, size                                                      | vkMapMemory                           => void **
===> VkDevice, VkDeviceMemory                                                                    | vkUnmapMemory                         =>
===> VkDevice, Vec<(VkDeviceMemory, offset, size)>                                               | vkInvalidateMappedMemoryRanges        =>
===> VkDevice, Vec<(VkDeviceMemory, offset, size)>                                               | vkFlushMappedMemoryRanges             =>

===> VkDevice, VkBufferCreateFlag, size, VkBufferUsageFlag, VkSharingMode, queue-indexes         | vkCreateBuffer                        => VkBuffer
===> VkDevice, VkBuffer, VkFormat, offset, range                                                 | vkCreateBufferView                    => VkBufferView
===> VkDevice, VkBuffer, VkDeviceMemory, offset                                                  | vkBindBufferMemory                    =>
===> VkDevice, VkBuffer                                                                          | vkGetBufferMemoryRequirements         => (size, align, typ)
===> VkDevice, VkBuffer                                                                          | vkGetBufferDeviceAddress              => VkDeviceAddress
===> VkDevice, VkBuffer                                                                          | vkGetBufferOpaqueCaptureAddress       => uint64

typedef enum VkBufferCreateFlag {                           typedef enum VkBufferUsageFlag {
    VK_BUFFER_CREATE_SPARSE_BINDING_BIT,                        VK_BUFFER_USAGE_TRANSFER_SRC_BIT,
    VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT,                      VK_BUFFER_USAGE_TRANSFER_DST_BIT,
    VK_BUFFER_CREATE_SPARSE_ALIASED_BIT,                        VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT,
    VK_BUFFER_CREATE_PROTECTED_BIT,                             VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT,
    VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT,         VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT,
}                                                               VK_BUFFER_USAGE_STORAGE_BUFFER_BIT,
                                                                VK_BUFFER_USAGE_INDEX_BUFFER_BIT,
typedef enum VkSharingMode {                                    VK_BUFFER_USAGE_VERTEX_BUFFER_BIT,
    VK_SHARING_MODE_EXCLUSIVE,                                  VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT,
    VK_SHARING_MODE_CONCURRENT,                                 VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT,
}                                                           }


===> VkDevice, VkImageCreateInfo                                                                 | vkCreateImage                         => VkImage
===> VkDevice, VkImage, VkImageViewType, VkFormat, VkComponentMapping, VkImageSubresourceRange   | vkCreateImageView                     => VkImageView
===> VkDevice, VkImage, VkDeviceMemory, offset                                                   | vkBindImageMemory                     =>
===> VkDevice, VkImage                                                                           | vkGetImageMemoryRequirements          => (size, align, typ)
===> VkDevice, VkImage, VkImageSubresource                                                       | vkGetImageSubresourceLayout           => VkSubresourceLayout


typedef struct VkImageCreateInfo {                  typedef enum VkImageLayout {                                        typedef enum VkSampleCountFlag {
    VkImageCreateFlag   flags;                          VK_IMAGE_LAYOUT_UNDEFINED,                                          VK_SAMPLE_COUNT_1_BIT,
    VkImageType         imageType;                      VK_IMAGE_LAYOUT_GENERAL,                                            VK_SAMPLE_COUNT_2_BIT,
    VkFormat            format;                         VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL,                           VK_SAMPLE_COUNT_4_BIT,
    VkExtent3D          extent;                         VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL,                   VK_SAMPLE_COUNT_8_BIT,
    uint32_t            mipLevels;                      VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL,                    VK_SAMPLE_COUNT_16_BIT,
    uint32_t            arrayLayers;                    VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL,                           VK_SAMPLE_COUNT_32_BIT,
    VkSampleCountFlag   samples;                        VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,                               VK_SAMPLE_COUNT_64_BIT,
    VkImageTiling       tiling;                         VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,                           }
    VkImageUsageFlags   usage;                          VK_IMAGE_LAYOUT_PREINITIALIZED,                                 typedef enum VkImageAspectFlag {
    VkSharingMode       sharingMode;                    VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL,         VK_IMAGE_ASPECT_COLOR_BIT,
    uint32_t            queueFamilyIndexCount;          VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL,         VK_IMAGE_ASPECT_DEPTH_BIT,
    const uint32_t*     pQueueFamilyIndices;            VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL,                           VK_IMAGE_ASPECT_STENCIL_BIT,
    VkImageLayout       initialLayout;                  VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL,                            VK_IMAGE_ASPECT_METADATA_BIT,
}                                                       VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL,                         VK_IMAGE_ASPECT_PLANE_0_BIT,
                                                        VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL,                          VK_IMAGE_ASPECT_PLANE_1_BIT,
                                                        VK_IMAGE_LAYOUT_PRESENT_SRC_KHR,                                    VK_IMAGE_ASPECT_PLANE_2_BIT,
                                                    }                                                                   }

typedef enum VkImageViewType {          typedef struct VkComponentMapping {     typedef enum VkComponentSwizzle {       typedef struct VkImageSubresourceRange {
    VK_IMAGE_VIEW_TYPE_1D,                  VkComponentSwizzle r;                   VK_COMPONENT_SWIZZLE_IDENTITY,          VkImageAspectFlag     aspectMask;
    VK_IMAGE_VIEW_TYPE_2D,                  VkComponentSwizzle g;                   VK_COMPONENT_SWIZZLE_ZERO,              uint32_t              baseMipLevel;
    VK_IMAGE_VIEW_TYPE_3D,                  VkComponentSwizzle b;                   VK_COMPONENT_SWIZZLE_ONE,               uint32_t              levelCount;
    VK_IMAGE_VIEW_TYPE_CUBE,                VkComponentSwizzle a;                   VK_COMPONENT_SWIZZLE_R,                 uint32_t              baseArrayLayer;
    VK_IMAGE_VIEW_TYPE_1D_ARRAY,        }                                           VK_COMPONENT_SWIZZLE_G,                 uint32_t              layerCount;
    VK_IMAGE_VIEW_TYPE_2D_ARRAY,                                                    VK_COMPONENT_SWIZZLE_B,             }
    VK_IMAGE_VIEW_TYPE_CUBE_ARRAY,                                                  VK_COMPONENT_SWIZZLE_A,
}                                                                               }

typedef struct VkImageSubresource {     typedef struct VkSubresourceLayout {
    VkImageAspectFlag  aspectMask;          VkDeviceSize    offset;
    uint32_t           mipLevel;            VkDeviceSize    size;
    uint32_t           arrayLayer;          VkDeviceSize    rowPitch;
}                                           VkDeviceSize    arrayPitch;
                                            VkDeviceSize    depthPitch;
                                        }


Presentations
=============

===> VkPhysicalDevice, VkSurface                                                                 | vkGetPhysicalDeviceSurfaceCapabilitiesKHR     => VkSurfaceCapabilitiesKHR
===> VkPhysicalDevice, VkSurface                                                                 | vkGetPhysicalDeviceSurfaceFormatsKHR          => Vec<VkSurfaceFormatKHR>
===> VkPhysicalDevice, VkSurface                                                                 | vkGetPhysicalDeviceSurfacePresentModesKHR     => Vec<VkPresentModeKHR>
===> VkPhysicalDevice, VkSurface, qf                                                             | vkGetPhysicalDeviceSurfaceSupportKHR          => bool
===> VkDevice, VkSurface, VkSwapchainCreateInfoKHR                                               | vkCreateSwapchainKHR                          => VkSwapchain
===> VkDevice, VkSwapchain                                                                       | vkGetSwapchainImagesKHR                       => Vec<VkImage>
===> VkDevice, VkSwapchain, VkSemaphore, VkFence, timeout                                        | vkAcquireNextImageKHR                         => VkImage

===> VkDevice, VkFramebufferCreateFlag, VkRenderPass, Vec<VkImageView>, width, height, layers    | vkCreateFramebuffer                           => VkFrameBuffer



typedef struct VkSurfaceCapabilitiesKHR {               typedef enum VkPresentModeKHR {         typedef struct VkSurfaceFormatKHR {     typedef enum VkColorSpaceKHR {
    uint32_t                    minImageCount;              VK_PRESENT_MODE_IMMEDIATE_KHR,          VkFormat           format;              VK_COLOR_SPACE_SRGB_NONLINEAR_KHR,
    uint32_t                    maxImageCount;              VK_PRESENT_MODE_MAILBOX_KHR,            VkColorSpaceKHR    colorSpace;      }
    VkExtent2D                  currentExtent;              VK_PRESENT_MODE_FIFO_KHR,           }
    VkExtent2D                  minImageExtent;             VK_PRESENT_MODE_FIFO_RELAXED_KHR,
    VkExtent2D                  maxImageExtent;         }
    uint32_t                    maxImageArrayLayers;
    VkSurfaceTransformFlags     supportedTransforms;
    VkSurfaceTransformFlags     currentTransform;
    VkCompositeAlphaFlags       supportedCompositeAlpha;
    VkImageUsageFlags           supportedUsageFlags;
}

typedef struct VkSwapchainCreateInfoKHR {                   typedef enum VkFramebufferCreateFlag {
    VkSwapchainCreateFlag            flags;                     VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT = 0x00000001,
    VkSurfaceKHR                     surface;               }
 +  uint32_t                         minImageCount;         typedef enum VkSurfaceTransformFlags {                          typedef enum VkCompositeAlphaFlags {
 +* VkFormat                         imageFormat;               VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR,                          VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR,
 +  VkColorSpaceKHR                  imageColorSpace;           VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR,                         VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR,
 +* VkExtent2D                       imageExtent;               VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR,                        VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR,
 +* uint32_t                         imageArrayLayers;          VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR,                        VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR,
 +* VkImageUsageFlags                imageUsage;                VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR,             }
  * VkSharingMode                    imageSharingMode;          VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR,
  * uint32_t                         queueFamilyIndexCount;     VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR,
  * const uint32_t*                  pQueueFamilyIndices;       VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR,
 +  VkSurfaceTransformFlags          preTransform;              VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR,
 +  VkCompositeAlphaFlags            compositeAlpha;        }
 +  VkPresentModeKHR                 presentMode;
 +  VkBool32                         clipped;
    VkSwapchainKHR                   oldSwapchain;
}


Renderpass, Sampler
===================

===> VkDevice, VkSamplerCreateInfo                                                                               | vkCreateSampler               => VkSampler


typedef struct VkSamplerCreateInfo {                    typedef enum VkSamplerAddressMode {                 typedef enum VkCompareOp {
    VkSamplerCreateFlag     flags;                          VK_SAMPLER_ADDRESS_MODE_REPEAT,                     VK_COMPARE_OP_NEVER,
    VkFilter                magFilter;                      VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT,            VK_COMPARE_OP_LESS,
    VkFilter                minFilter;                      VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE,              VK_COMPARE_OP_EQUAL,
    VkSamplerMipmapMode     mipmapMode;                     VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER,            VK_COMPARE_OP_LESS_OR_EQUAL,
    VkSamplerAddressMode    addressModeU;                   VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE,       VK_COMPARE_OP_GREATER,
    VkSamplerAddressMode    addressModeV;               }                                                       VK_COMPARE_OP_NOT_EQUAL,
    VkSamplerAddressMode    addressModeW;                                                                       VK_COMPARE_OP_GREATER_OR_EQUAL,
    float                   mipLodBias;                 typedef enum VkSamplerMipmapMode {                      VK_COMPARE_OP_ALWAYS,
    VkBool32                anisotropyEnable;               VK_SAMPLER_MIPMAP_MODE_NEAREST,                 }
    float                   maxAnisotropy;                  VK_SAMPLER_MIPMAP_MODE_LINEAR,                  typedef enum VkBorderColor {
    VkBool32                compareEnable;              }                                                       VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK,
    VkCompareOp             compareOp;                  typedef enum VkFilter {                                 VK_BORDER_COLOR_INT_TRANSPARENT_BLACK,
    float                   minLod;                         VK_FILTER_NEAREST,                                  VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK,
    float                   maxLod;                         VK_FILTER_LINEAR,                                   VK_BORDER_COLOR_INT_OPAQUE_BLACK,
    VkBorderColor           borderColor;                }                                                       VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE,
    VkBool32                unnormalizedCoordinates;    typedef enum VkSamplerCreateFlag {                      VK_BORDER_COLOR_INT_OPAQUE_WHITE,
}                                                           VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT,           }
                                                            VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT,
                                                        }


===> VkDevice, VkRenderPassCreateInfo                                                                            | vkCreateRenderPass            => VkRenderPass


typedef struct VkRenderPassCreateInfo {                 typedef enum VkAttachmentDescriptionFlag {          typedef enum VkPipelineBindPoint {
  x VkRenderPassCreateFlags         flags;                 VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT,            VK_PIPELINE_BIND_POINT_GRAPHICS,
    uint32_t                        attachmentCount;    }                                                      VK_PIPELINE_BIND_POINT_COMPUTE,
    const VkAttachmentDescription*  pAttachments;       typedef enum VkAttachmentLoadOp {                   }
    uint32_t                        subpassCount;          VK_ATTACHMENT_LOAD_OP_LOAD,                      typedef struct VkAttachmentReference {
    const VkSubpassDescription*     pSubpasses;            VK_ATTACHMENT_LOAD_OP_CLEAR,                        uint32_t         attachment;
    uint32_t                        dependencyCount;       VK_ATTACHMENT_LOAD_OP_DONT_CARE,                    VkImageLayout    layout;
    const VkSubpassDependency*      pDependencies;      }                                                   }
}                                                       typedef enum VkAttachmentStoreOp {                  typedef enum VkDependencyFlags {
                                                           VK_ATTACHMENT_STORE_OP_STORE = 0,                   VK_DEPENDENCY_BY_REGION_BIT,
                                                           VK_ATTACHMENT_STORE_OP_DONT_CARE = 1,               VK_DEPENDENCY_DEVICE_GROUP_BIT,
                                                        }                                                      VK_DEPENDENCY_VIEW_LOCAL_BIT,
                                                                                                            }

typedef struct VkAttachmentDescription {        typedef struct VkSubpassDescription {                       typedef struct VkSubpassDependency {
    VkAttachmentDescriptionFlag flags;            x VkSubpassDescriptionFlags    flags;                         uint32_t                srcSubpass;
    VkFormat                    format;             VkPipelineBindPoint          pipelineBindPoint;             uint32_t                dstSubpass;
    VkSampleCountFlag           samples;            uint32_t                     inputAttachmentCount;          VkPipelineStageFlags    srcStageMask;
    VkAttachmentLoadOp          loadOp;             const VkAttachmentReference* pInputAttachments;             VkPipelineStageFlags    dstStageMask;
    VkAttachmentStoreOp         storeOp;            uint32_t                     colorAttachmentCount;          VkAccessFlags           srcAccessMask;
    VkAttachmentLoadOp          stencilLoadOp;      const VkAttachmentReference* pColorAttachments;             VkAccessFlags           dstAccessMask;
    VkAttachmentStoreOp         stencilStoreOp;     const VkAttachmentReference* pResolveAttachments;           VkDependencyFlags       dependencyFlags;
    VkImageLayout               initialLayout;      const VkAttachmentReference* pDepthStencilAttachment;   }
    VkImageLayout               finalLayout;        uint32_t                     preserveAttachmentCount;
}                                                   const uint32_t*              pPreserveAttachments;
                                                }

typedef enum VkAccessFlags {                        typedef enum VkPipelineStageFlags {
    VK_ACCESS_INDIRECT_COMMAND_READ_BIT,                VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT,
    VK_ACCESS_INDEX_READ_BIT,                           VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT,
    VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT,                VK_PIPELINE_STAGE_VERTEX_INPUT_BIT,
    VK_ACCESS_UNIFORM_READ_BIT,                         VK_PIPELINE_STAGE_VERTEX_SHADER_BIT,
    VK_ACCESS_INPUT_ATTACHMENT_READ_BIT,                VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT,
    VK_ACCESS_SHADER_READ_BIT,                          VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT,
    VK_ACCESS_SHADER_WRITE_BIT,                         VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT,
    VK_ACCESS_COLOR_ATTACHMENT_READ_BIT,                VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT,
    VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT,               VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT,
    VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT,        VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT,
    VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT,       VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT,
    VK_ACCESS_TRANSFER_READ_BIT,                        VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,
    VK_ACCESS_TRANSFER_WRITE_BIT,                       VK_PIPELINE_STAGE_TRANSFER_BIT,
    VK_ACCESS_HOST_READ_BIT,                            VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT,
    VK_ACCESS_HOST_WRITE_BIT,                           VK_PIPELINE_STAGE_HOST_BIT,
    VK_ACCESS_MEMORY_READ_BIT,                          VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT,
    VK_ACCESS_MEMORY_WRITE_BIT,                         VK_PIPELINE_STAGE_ALL_COMMANDS_BIT,
    VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR,  }
    VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR,
    VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR,
    VK_ACCESS_NONE_KHR,
}


DescriptorSets
==============

* A descriptor set is an opaque data structure representing a shader resource such as a buffer, buffer view, image view, sampler, or combined image sampler.
* A descriptor set is a set of resources bound into pipeline as a group and each set has a layout, called descriptor-set-layout.
* Each set has a layout that describes the order and type of resources in the set.
* Two sets with same layout are considered compatible and interchangeable.
* Multiple set, called pipeline-layout, can be aggregated and bound to a pipeline.
* If VkDescriptorType is VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, then VkDescriptorImageInfo::VkSampler field is meaningful.
* To return all descriptor sets allocated from a given pool back to the pool, rather than freeing individual descriptor sets, call vkResetDescriptorPool.

pData - VkDescriptorImageInfo or VkDescriptorBufferInfo or VkBufferView

===> VkDevice, VkDescriptorPoolCreateInfo                                                            | vkCreateDescriptorPool                => VkDescriptorPool
===> VkDevice, VkDescriptorPool                                                                      | vkResetDescriptorPool                 =>


typedef struct VkDescriptorPoolCreateInfo {             typedef enum VkDescriptorPoolCreateFlags {                  typedef enum VkDescriptorType {
    VkDescriptorPoolCreateFlags    flags;                   VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT,          VK_DESCRIPTOR_TYPE_SAMPLER,
    uint32_t                       maxSets;                 VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT,            VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,
    uint32_t                       poolSizeCount;       }                                                               VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
    const VkDescriptorPoolSize*    pPoolSizes;          typedef struct VkDescriptorPoolSize {                           VK_DESCRIPTOR_TYPE_STORAGE_IMAGE,
}                                                           VkDescriptorType    type;                                   VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER,
                                                            uint32_t            descriptorCount;                        VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER,
                                                        }                                                               VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
                                                                                                                        VK_DESCRIPTOR_TYPE_STORAGE_BUFFER,
                                                                                                                        VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC,
                                                                                                                        VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC,
                                                                                                                        VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT,
                                                                                                                    }


===> VkDevice, VkDescriptorSetLayoutCreateInfo                                                       | vkGetDescriptorSetLayoutSupport       => VkBool32
===> VkDevice, VkDescriptorSetLayoutCreateInfo                                                       | vkCreateDescriptorSetLayout           => VkDescriptorSetLayout


typedef struct VkDescriptorSetLayoutCreateInfo {            typedef enum VkDescriptorSetLayoutCreateFlags {                     typedef enum VkShaderStageFlags {
    VkDescriptorSetLayoutCreateFlags       flags;               VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT,         VK_SHADER_STAGE_VERTEX_BIT,
    uint32_t                               bindingCount;        VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR,            VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT,
    const VkDescriptorSetLayoutBinding*    pBindings;       }                                                                       VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT,
}                                                           typedef struct VkDescriptorSetLayoutBinding {                           VK_SHADER_STAGE_GEOMETRY_BIT,
                                                                uint32_t              binding;                                      VK_SHADER_STAGE_FRAGMENT_BIT,
                                                                VkDescriptorType      descriptorType;                               VK_SHADER_STAGE_COMPUTE_BIT,
                                                                uint32_t              descriptorCount;                              VK_SHADER_STAGE_ALL_GRAPHICS,
                                                                VkShaderStageFlags    stageFlags;                                   VK_SHADER_STAGE_ALL,
                                                                const VkSampler*      pImmutableSamplers;                       }
                                                            }


===> VkDevice, VkDescriptorSetAllocateInfo                                                           | vkAllocateDescriptorSets              => Vec<VkDescriptorSet>
===> VkDevice, Vec<VkWriteDescriptorSet>, Vec<VkCopyDescriptorSet>                                   | vkUpdateDescriptorSets                =>
===> VkDevice, VkDescriptorUpdateTemplateCreateInfo                                                  | vkCreateDescriptorUpdateTemplate      => VkDescriptorUpdateTemplate
===> VkDevice, VkDescriptorSet, VkDescriptorUpdateTemplate, pData                                    | vkUpdateDescriptorSetWithTemplate     =>
===> VkDevice, VkDescriptorPool, Vec<VkDescriptorSet>                                                | vkFreeDescriptorSets

typedef struct VkDescriptorSetAllocateInfo {
    VkDescriptorPool                descriptorPool;
    uint32_t                        descriptorSetCount;
    const VkDescriptorSetLayout*    pSetLayouts;
}

typedef struct VkCopyDescriptorSet {        typedef struct VkWriteDescriptorSet {                       typedef struct VkDescriptorImageInfo {
    VkDescriptorSet    srcSet;                  VkDescriptorSet                  dstSet;                    VkSampler        sampler;
    uint32_t           srcBinding;              uint32_t                         dstBinding;                VkImageView      imageView;
    uint32_t           srcArrayElement;         uint32_t                         dstArrayElement;           VkImageLayout    imageLayout;
    VkDescriptorSet    dstSet;                  uint32_t                         descriptorCount;       }
    uint32_t           dstBinding;              VkDescriptorType                 descriptorType;        typedef struct VkDescriptorBufferInfo {
    uint32_t           dstArrayElement;         const VkDescriptorImageInfo*     pImageInfo;                VkBuffer        buffer;
    uint32_t           descriptorCount;         const VkDescriptorBufferInfo*    pBufferInfo;               VkDeviceSize    offset;
}                                               const VkBufferView*              pTexelBufferView;          VkDeviceSize    range;
                                            }                                                           }


typedef struct VkDescriptorUpdateTemplateCreateInfo {                       typedef enum VkDescriptorUpdateTemplateType {               typedef struct VkDescriptorUpdateTemplateEntry {
  x VkDescriptorUpdateTemplateCreateFlags     flags;                            VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET,          uint32_t            dstBinding;
    uint32_t                                  descriptorUpdateEntryCount;       VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR,    uint32_t            dstArrayElement;
    const VkDescriptorUpdateTemplateEntry*    pDescriptorUpdateEntries;     }                                                               uint32_t            descriptorCount;
    VkDescriptorUpdateTemplateType            templateType;                                                                                 VkDescriptorType    descriptorType;
    VkDescriptorSetLayout                     descriptorSetLayout;                                                                          size_t              offset;
    VkPipelineBindPoint                       pipelineBindPoint;                                                                            size_t              stride;
    VkPipelineLayout                          pipelineLayout;                                                                           }
    uint32_t                                  set;
}


Pipelines
=========

* Two pipelines can use same set of descriptor sets, provided they are compatible. For pipeline-layouts to be compatible:
  * Use the same number of push constant ranges.
  * Use the same descript set layouts (or identical layouts) in the same order.
* Two pipeline-layouts are partially compatible if they use the same (or identical) set layouts for the first few sets.
* Switching between two (partially) compatible pipelines doesnot require re-binding any sets upto the point where the pipeline share the layout.


===> VkDevice, VkShaderModuleCreateInfo                                                                                 | vkCreateShaderModule          => VkShaderModule
===> VkDevice, VkPipelineCacheCreateInfo                                                                                | vkCreatePipelineCache         => VkPipelineCache
===> VkDevice, VkPipelineCache                                                                                          | vkGetPipelineCacheData        => pData
===> VkDevice, VkPipelineCache, Vec<VkPipelineCache>                                                                    | vkMergePipelineCaches         =>

typedef struct VkShaderModuleCreateInfo {       typedef struct VkPipelineCacheCreateInfo {
  x VkShaderModuleCreateFlags    flags;           x VkPipelineCacheCreateFlags    flags;
    size_t                       codeSize;          size_t                        initialDataSize;
    const uint32_t*              pCode;             const void*                   pInitialData;
}                                               }



===> VkDevice, VkPipelineLayoutCreateInfo                                                                               | vkCreatePipelineLayout        => VkPipelineLayout

typedef struct VkPipelineLayoutCreateInfo {                     typedef struct VkPushConstantRange {
  x VkPipelineLayoutCreateFlags     flags;                          VkShaderStageFlags    stageFlags;
    uint32_t                        setLayoutCount;                 uint32_t              offset;
    const VkDescriptorSetLayout*    pSetLayouts;                    uint32_t              size;
    uint32_t                        pushConstantRangeCount;     }
    const VkPushConstantRange*      pPushConstantRanges;
}



===> VkDevice, VkPipelineCache, Vec<VkComputePipelineCreateInfo>                                                        | vkCreateComputePipelines      => Vec<VkPipeline>

typedef struct VkComputePipelineCreateInfo {                    typedef enum VkPipelineCreateFlags {
    VkPipelineCreateFlags              flags;                       VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT,
    VkPipelineShaderStageCreateInfo    stage;                       VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT,
    VkPipelineLayout                   layout;                      VK_PIPELINE_CREATE_DERIVATIVE_BIT,
    VkPipeline                         basePipelineHandle;          VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT,
    int32_t                            basePipelineIndex;           VK_PIPELINE_CREATE_DISPATCH_BASE_BIT,
}                                                                   VK_PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR,
                                                                    VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR,
                                                                    VK_PIPELINE_CREATE_LIBRARY_BIT_KHR,
                                                                }

typedef struct VkPipelineShaderStageCreateInfo {                typedef struct VkSpecializationInfo {                   typedef struct VkSpecializationMapEntry {
  x VkPipelineShaderStageCreateFlags    flags;                      uint32_t                           mapEntryCount;       uint32_t    constantID;
    VkShaderStageFlags                  stage;                      const VkSpecializationMapEntry*    pMapEntries;         uint32_t    offset;
    VkShaderModule                      module;                     size_t                             dataSize;            size_t      size;
    const char*                         pName;                      const void*                        pData;           }
    const VkSpecializationInfo*         pSpecializationInfo;    }
}



===> VkDevice, VkPipelineCache, Vec<VkGraphicsPipelineCreateInfo>                                                    | vkCreateGraphicsPipelines     => Vec<VkPipeline>


typedef struct VkGraphicsPipelineCreateInfo {                                   typedef struct VkPipelineVertexInputStateCreateInfo {
    VkPipelineCreateFlags                            flags;                       x VkPipelineVertexInputStateCreateFlags       flags;
    uint32_t                                         stageCount;                    uint32_t                                    vertexBindingDescriptionCount;
    const VkPipelineShaderStageCreateInfo*           pStages;                       const VkVertexInputBindingDescription*      pVertexBindingDescriptions;
    const VkPipelineVertexInputStateCreateInfo*      pVertexInputState;             uint32_t                                    vertexAttributeDescriptionCount;
    const VkPipelineInputAssemblyStateCreateInfo*    pInputAssemblyState;           const VkVertexInputAttributeDescription*    pVertexAttributeDescriptions;
    const VkPipelineTessellationStateCreateInfo*     pTessellationState;        }
    const VkPipelineViewportStateCreateInfo*         pViewportState;            typedef struct VkVertexInputAttributeDescription {
    const VkPipelineRasterizationStateCreateInfo*    pRasterizationState;           uint32_t    location;
    const VkPipelineMultisampleStateCreateInfo*      pMultisampleState;             uint32_t    binding;
    const VkPipelineDepthStencilStateCreateInfo*     pDepthStencilState;            VkFormat    format;
    const VkPipelineColorBlendStateCreateInfo*       pColorBlendState;              uint32_t    offset;
    const VkPipelineDynamicStateCreateInfo*          pDynamicState;             }
    VkPipelineLayout                                 layout;                    typedef struct VkVertexInputBindingDescription {
    VkRenderPass                                     renderPass;                    uint32_t             binding;
    uint32_t                                         subpass;                       uint32_t             stride;
    VkPipeline                                       basePipelineHandle;            VkVertexInputRate    inputRate;
    int32_t                                          basePipelineIndex;         }
}                                                                               typedef enum VkVertexInputRate {
                                                                                    VK_VERTEX_INPUT_RATE_VERTEX = 0,
typedef struct VkPipelineInputAssemblyStateCreateInfo {                             VK_VERTEX_INPUT_RATE_INSTANCE = 1,
  x VkPipelineInputAssemblyStateCreateFlags    flags;                           }
    VkPrimitiveTopology                        topology;
    VkBool32                                   primitiveRestartEnable;          typedef struct VkPipelineViewportStateCreateInfo {  typedef struct VkViewport {
}                                                                                   uint32_t                viewportCount;              float    x;
typedef struct VkPipelineTessellationStateCreateInfo {                              const VkViewport*       pViewports;                 float    y;
  x VkPipelineTessellationStateCreateFlags    flags;                                uint32_t                scissorCount;               float    width;
    uint32_t                                  patchControlPoints;                   const VkRect2D*         pScissors;                  float    height;
}                                                                               }                                                       float    minDepth;
                                                                                                                                        float    maxDepth;
                                                                                                                                    }
typedef struct VkPipelineRasterizationStateCreateInfo {     typedef enum VkPolygonMode {                typedef enum VkDynamicState {
    VkBool32        depthClampEnable;                           VK_POLYGON_MODE_FILL,                       VK_DYNAMIC_STATE_VIEWPORT,
    VkBool32        rasterizerDiscardEnable;                    VK_POLYGON_MODE_LINE,                       VK_DYNAMIC_STATE_SCISSOR,
    VkPolygonMode   polygonMode;                                VK_POLYGON_MODE_POINT,                      VK_DYNAMIC_STATE_LINE_WIDTH,
    VkCullModeFlags cullMode;                               }                                               VK_DYNAMIC_STATE_DEPTH_BIAS,
    VkFrontFace     frontFace;                              typedef enum VkCullModeFlags {                  VK_DYNAMIC_STATE_BLEND_CONSTANTS,
    VkBool32        depthBiasEnable;                            VK_CULL_MODE_NONE,                          VK_DYNAMIC_STATE_DEPTH_BOUNDS,
    float           depthBiasConstantFactor;                    VK_CULL_MODE_FRONT_BIT,                     VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK,
    float           depthBiasClamp;                             VK_CULL_MODE_BACK_BIT,                      VK_DYNAMIC_STATE_STENCIL_WRITE_MASK,
    float           depthBiasSlopeFactor;                       VK_CULL_MODE_FRONT_AND_BACK,                VK_DYNAMIC_STATE_STENCIL_REFERENCE,
    float           lineWidth;                              }                                           }
}                                                           typedef enum VkFrontFace {
                                                                 VK_FRONT_FACE_COUNTER_CLOCKWISE,
                                                                 VK_FRONT_FACE_CLOCKWISE,
                                                             }

typedef struct VkPipelineDynamicStateCreateInfo {
    VkPipelineDynamicStateCreateFlags    flags;
    uint32_t                             dynamicStateCount;
    const VkDynamicState*                pDynamicStates;
}


CommandBuffer
=============

+-------+                       +---------+
| State |                       | Execute |
+-------+                       +---------+

* bind-point-VkDescriptorSet    * Set, Bind, Push
* compute-pipeline              * Copy, Fill, Update, Clear, Blit
* graphics-pipeline             * Draw, Resolve
  * Index-buffer                * Dispatch
  * Vertex-buffers              * Query
* push-constants                * PipelineBarrier, Event
* viewPort
* scissors
* blend-constants
* depthBias
  * constantFactor
  * clamp
  * slopeFactor
* depthBound
  * min, max
* device-mask
* line-width


===> VkDevice, VkCommandPoolCreateFlags, queue-family                                        | vkCreateCommandPool           => VkCommandPool
===> VkDevice, VkCommandPool, VkCommandPoolResetFlags                                        | vkResetCommandPool
===> VkDevice, VkCommandPool                                                                 | vkTrimCommandPool

typedef enum VkCommandPoolCreateFlags {                 typedef enum VkCommandPoolResetFlags {
    VK_COMMAND_POOL_CREATE_TRANSIENT_BIT,                   VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT,
    VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT,    }
    VK_COMMAND_POOL_CREATE_PROTECTED_BIT,
}



===> VkDevice, VkCommandPool, VkCommandBufferLevel, count                                        | vkAllocateCommandBuffers      Vec<VkCommandBuffer>
===> VkCommandBuffer, VkCommandBufferUsageFlags, VkCommandBufferInheritanceInfo                  | vkBeginCommandBuffer
===> VkCommandBuffer, VkQueryPool, query-index, VkQueryControlFlags                              | vkCmdBeginQuery
===> VkCommandBuffer, VkRenderPassBeginInfo, VkSubpassContents                                   | vkCmdBeginRenderPass

typedef struct VkCommandBufferInheritanceInfo {                 typedef enum VkQueryPipelineStatisticFlags {                        typedef enum VkCommandBufferUsageFlags {
    VkStructureType                  sType;                         VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT,            VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT,
    const void*                      pNext;                         VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT,          VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT,
    VkRenderPass                     renderPass;                    VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT,          VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT,
    uint32_t                         subpass;                       VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT,    }
    VkFramebuffer                    framebuffer;                   VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT,                 typedef enum VkCommandBufferLevel {
    VkBool32                         occlusionQueryEnable;          VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT,                           VK_COMMAND_BUFFER_LEVEL_PRIMARY,
    VkQueryControlFlags              queryFlags;                    VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT,                            VK_COMMAND_BUFFER_LEVEL_SECONDARY,
    VkQueryPipelineStatisticFlags    pipelineStatistics;            VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT,                }
}                                                                   VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT,
                                                                    VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT,
typedef enum VkQueryControlFlags {                                  VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT,
    VK_QUERY_CONTROL_PRECISE_BIT,                               }
}


typedef struct VkRenderPassBeginInfo {          typedef enum VkSubpassContents {                    typedef union VkClearColorValue {
    VkRenderPass           renderPass;              VK_SUBPASS_CONTENTS_INLINE,                         float       float32[4];
    VkFramebuffer          framebuffer;             VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS,      int32_t     int32[4];
    VkRect2D               renderArea;          }                                                       uint32_t    uint32[4];
    uint32_t               clearValueCount;     typedef union VkClearValue {                        }
    const VkClearValue*    pClearValues;            VkClearColorValue           color;              typedef struct VkClearDepthStencilValue {
}                                                   VkClearDepthStencilValue    depthStencil;           float       depth;
                                                }                                                       uint32_t    stencil;
                                                                                                    }


===> VkCommandBuffer, blendConstants[4]                                                          | vkCmdSetBlendConstants
===> VkCommandBuffer, constantFactor, clamp, slopeFactor                                         | vkCmdSetDepthBias
===> VkCommandBuffer, min, max                                                                   | vkCmdSetDepthBounds
===> VkCommandBuffer, deviceMask                                                                 | vkCmdSetDeviceMask
===> VkCommandBuffer, lineWidth                                                                  | vkCmdSetLineWidth
===> VkCommandBuffer, first-index, count, Vec<VkRect2D>                                          | vkCmdSetScissor
===> VkCommandBuffer, VkStencilFaceFlags, compareMask                                            | vkCmdSetStencilCompareMask
===> VkCommandBuffer, VkStencilFaceFlags, reference                                              | vkCmdSetStencilReference
===> VkCommandBuffer, VkStencilFaceFlags, writeMask                                              | vkCmdSetStencilWriteMask
===> VkCommandBuffer, first-index, count, Vec<VkViewport>                                        | vkCmdSetViewport

typedef enum VkStencilFaceFlags {
    VK_STENCIL_FACE_FRONT_BIT,
    VK_STENCIL_FACE_BACK_BIT,
    VK_STENCIL_FACE_FRONT_AND_BACK,
    VK_STENCIL_FRONT_AND_BACK,
}

===> VkCommandBuffer, VkPipelineBindPoint, VkPipelineLayout, Vec<VkDescriptorSet>, Vec<offsets>  | vkCmdBindDescriptorSets
===> VkCommandBuffer, VkPipelineBindPoint, VkPipeline                                            | vkCmdBindPipeline
===> VkCommandBuffer, VkBuffer, size, VkIndexType                                                | vkCmdBindIndexBuffer
===> VkCommandBuffer, first-binding, count, Vec<(VkBuffer, offsets)>                             | vkCmdBindVertexBuffers
===> VkCommandBuffer, VkImage, VkImageLayout, VkImage, VkImageLayout, Vec<VkImageBlit>, VkFilter | vkCmdBlitImage


typedef struct VkImageBlit {                        typedef struct VkImageSubresourceLayers {   typedef enum VkImageAspectFlags {       typedef enum VkIndexType {
    VkImageSubresourceLayers    srcSubresource;         VkImageAspectFlags    aspectMask;           VK_IMAGE_ASPECT_COLOR_BIT,              VK_INDEX_TYPE_UINT16,
    VkOffset3D                  srcOffsets[2];          uint32_t              mipLevel;             VK_IMAGE_ASPECT_DEPTH_BIT,              VK_INDEX_TYPE_UINT32,
    VkImageSubresourceLayers    dstSubresource;         uint32_t              baseArrayLayer;       VK_IMAGE_ASPECT_STENCIL_BIT,            VK_INDEX_TYPE_NONE_KHR,
    VkOffset3D                  dstOffsets[2];          uint32_t              layerCount;           VK_IMAGE_ASPECT_METADATA_BIT,       }
}                                                   }                                               VK_IMAGE_ASPECT_PLANE_0_BIT,
                                                                                                    VK_IMAGE_ASPECT_PLANE_1_BIT,
                                                                                                    VK_IMAGE_ASPECT_PLANE_2_BIT,
                                                                                                }


===> VkCommandBuffer, Vec<VkClearAttachment>, Vec<VkClearRect>                                       | vkCmdClearAttachments
===> VkCommandBuffer, VkImage, VkImageLayout, VkClearColorValue, Vec<VkImageSubresourceRange>        | vkCmdClearColorImage
===> VkCommandBuffer, VkImage, VkImageLayout, VkClearDepthStencilValue, Vec<VkImageSubresourceRange> | vkCmdClearDepthStencilImage
===> VkCommandBuffer, VkBuffer, dstOffset, size, pData                                               | vkCmdFillBuffer
===> VkCommandBuffer, VkBuffer, dstOffset, size, pData                                               | vkCmdUpdateBuffer
===> VkCommandBuffer, VkBuffer, VkBuffer, Vec<VkBufferCopy>                                          | vkCmdCopyBuffer
===> VkCommandBuffer, VkBuffer, VkImage, VkImageLayout, Vec<VkBufferImageCopy>                       | vkCmdCopyBufferToImage
===> VkCommandBuffer, VkImage, VkImageLayout, VkImage, VkImageLayout, Vec<VkImageCopy>               | vkCmdCopyImage
===> VkCommandBuffer, VkImage, VkImageLayout, VkBuffer, Vec<VkBufferImageCopy>                       | vkCmdCopyImageToBuffer


typedef struct VkBufferImageCopy {                  typedef struct VkClearAttachment {          typedef struct VkClearRect {        typedef struct VkBufferCopy {
    VkDeviceSize                bufferOffset;           VkImageAspectFlags    aspectMask;           VkRect2D    rect;                   VkDeviceSize    srcOffset;
    uint32_t                    bufferRowLength;        uint32_t              colorAttachment;      uint32_t    baseArrayLayer;         VkDeviceSize    dstOffset;
    uint32_t                    bufferImageHeight;      VkClearValue          clearValue;           uint32_t    layerCount;             VkDeviceSize    size;
    VkImageSubresourceLayers    imageSubresource;   }                                           }                                   }
    VkOffset3D                  imageOffset;
    VkExtent3D                  imageExtent;
}

typedef struct VkImageCopy {                        typedef enum VkQueryResultFlags {
    VkImageSubresourceLayers    srcSubresource;         VK_QUERY_RESULT_64_BIT,
    VkOffset3D                  srcOffset;              VK_QUERY_RESULT_WAIT_BIT,
    VkImageSubresourceLayers    dstSubresource;         VK_QUERY_RESULT_WITH_AVAILABILITY_BIT,
    VkOffset3D                  dstOffset;              VK_QUERY_RESULT_PARTIAL_BIT,
    VkExtent3D                  extent;             }
}


===> VkCommandBuffer, VkQueryPool, firstQuery, queryCount, VkBuffer, dstOffset, stride, VkQueryResultFlags   | vkCmdCopyQueryPoolResults
===> VkCommandBuffer, VkQueryPool, firstQuery, queryCount                                                    | vkCmdResetQueryPool
===> VkCommandBuffer, VkQueryPool, VkPipelineStageFlags, query                                               | vkCmdWriteTimestamp
===> VkCommandBuffer, VkQueryPool, query                                                                     | vkCmdEndQuery

===> VkCommandBuffer, vertexCount, instanceCount, firstVertex, firstInstance                                 | vkCmdDraw
===> VkCommandBuffer, indexCount, instanceCount, firstIndex, vertexOffset, firstInstance                     | vkCmdDrawIndexed
===> VkCommandBuffer, VkBuffer, offset, drawCount, stride                                                    | vkCmdDrawIndexedIndirect
===> VkCommandBuffer, VkBuffer, offset, VkBuffer, countBufferOffset, maxDrawCount, stride                    | vkCmdDrawIndexedIndirectCount
===> VkCommandBuffer, VkBuffer, offset, drawCount, stride                                                    | vkCmdDrawIndirect
===> VkCommandBuffer, VkBuffer, offset, VkBuffer, countBufferOffset, maxDrawCount, stride                    | vkCmdDrawIndirectCount

===> VkCommandBuffer                                                                                         | vkCmdEndRenderPass
===> VkCommandBuffer, Vec<VkCommandBuffer>                                                                   | vkCmdExecuteCommands
===> VkCommandBuffer, VkSubpassContents                                                                      | vkCmdNextSubpass
===> VkCommandBuffer, VkBarrierInfo                                                                          | vkCmdPipelineBarrier
===> VkCommandBuffer, VkPipelineLayout, VkShaderStageFlags, offset, size, pValues                            | vkCmdPushConstants
===> VkCommandBuffer, VkPipelineBindPoint, VkPipelineLayout, set, Vec<VkWriteDescriptorSet>                  | vkCmdPushDescriptorSetKHR
===> VkCommandBuffer, VkDescriptorUpdateTemplate, VkPipelineLayout, set, pData                               | vkCmdPushDescriptorSetWithTemplateKHR


typedef struct VkBarrierInfo {                                  typedef struct VkImageMemoryBarrier {                   typedef struct VkBufferMemoryBarrier {
    VkCommandBuffer                 commandBuffer,                  VkAccessFlags              srcAccessMask;               VkAccessFlags      srcAccessMask;
    VkPipelineStageFlags            srcStageMask,                   VkAccessFlags              dstAccessMask;               VkAccessFlags      dstAccessMask;
    VkPipelineStageFlags            dstStageMask,                   VkImageLayout              oldLayout;                   uint32_t           srcQueueFamilyIndex;
    VkDependencyFlags               dependencyFlags,                VkImageLayout              newLayout;                   uint32_t           dstQueueFamilyIndex;
    uint32_t                        memoryBarrierCount,             uint32_t                   srcQueueFamilyIndex;         VkBuffer           buffer;
    const VkMemoryBarrier*          pMemoryBarriers,                uint32_t                   dstQueueFamilyIndex;         VkDeviceSize       offset;
    uint32_t                        bufferMemoryBarrierCount,       VkImage                    image;                       VkDeviceSize       size;
    const VkBufferMemoryBarrier*    pBufferMemoryBarriers,          VkImageSubresourceRange    subresourceRange;        }
    uint32_t                        imageMemoryBarrierCount,    }                                                       typedef struct VkMemoryBarrier {
    const VkImageMemoryBarrier*     pImageMemoryBarriers);                                                                  VkAccessFlags      srcAccessMask;
}                                                                                                                           VkAccessFlags      dstAccessMask;
                                                                                                                        }


===> VkCommandBuffer, VkEvent, VkPipelineStageFlags                                                          | vkCmdResetEvent
===> VkCommandBuffer, VkEvent, VkPipelineStageFlags                                                          | vkCmdSetEvent
===> VkCommandBuffer, Vec<VkEvent>, VkBarrierInfo                                                            | vkCmdWaitEvents
===> VkCommandBuffer, VkImage, VkImageLayout, VkImage, VkImageLayout, Vec<VkImageResolve>                    | vkCmdResolveImage

typedef struct VkImageResolve {
    VkImageSubresourceLayers    srcSubresource;
    VkOffset3D                  srcOffset;
    VkImageSubresourceLayers    dstSubresource;
    VkOffset3D                  dstOffset;
    VkExtent3D                  extent;
}


===> VkCommandBuffer                                                                                         | vkEndCommandBuffer
===> VkCommandBuffer, VkCommandBufferResetFlags                                                              | vkResetCommandBuffer
===> VkDevice, VkCommandPool, Vec<VkCommandBuffer>                                                           | vkFreeCommandBuffers

typedef enum VkCommandBufferResetFlags {
    VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT
}

Synchronisation
===============

* Execution between host and device is async.
* Execution between queues within device is async.
* Execution of commands and command-buffer start in submission order but can finish out of order.
* Synchronization between host and device and between queues, application responsibility

Implicit ordering guarantees                Fences, Sempahores, Events, Pipeline-barriers, Renderpasses
Explicit synchronisation primitives
Semaphore wait operation                    Synchronization commands introduce explicit execution dependencies, and memory dependencies between
Semaphore signal operation                  two sets of operations defined by the command’s two synchronization scopes.
Fence wait operation
Fence signal operation

Processing/execution order

* Primitive order
* Submission order
* Pipeline order
* Rasterization order
* Dispatch order

A memory dependency is an execution dependency which includes availability and visibility operations such that:

* The first set of operations happens-before the availability operation.
* The availability operation happens-before the visibility operation.
* The visibility operation happens-before the second set of operations.

Event Synchronization primitives are used to insert a fine-grained dependency between commands submitted to the same queue, or between the host and a queue.

Image subresources can be transitioned from one layout to another as part of a memory dependency


===> VkDevice                                                                                                | vkCreateSemaphore
===> VkDevice, VkSemaphore, value_u64                                                                        | vkSignalSemaphore
===> VkDevice, VkSemaphoreWaitFlags Vec<VkSemaphore>, Vec<value_u64> timeout                                 | vkWaitSemaphores

===> VkDevice, VkEventCreateFlags                                                                            | vkCreateEvent
===> VkDevice, VkEvent                                                                                       | vkGetEventStatus
===> VkDevice, VkEvent                                                                                       | vkResetEvent
===> VkDevice, VkEvent                                                                                       | vkSetEvent
===> VkCommandBuffer, VkEvent, VkPipelineStageFlags                                                          | vkCmdResetEvent
===> VkCommandBuffer, VkEvent, VkPipelineStageFlags                                                          | vkCmdSetEvent
===> VkCommandBuffer, Vec<VkEvent>, VkBarrierInfo                                                            | vkCmdWaitEvents
===> VkDevice, VkEvent                                                                                       | vkDestroyEvent

===> VkDevice, VkFenceCreateFlags                                                                            | vkCreateFence
===> VkDevice, VkFence, VkExternalFenceHandleTypeFlags                                                       | vkGetFenceFdKHR           => pFd
===> VkDevice, VkFence, VkFenceImportFlags, VkExternalFenceHandleTypeFlags                                   | VkImportFenceFdInfoKHR
===> VkDevice, VkFence                                                                                       | vkGetFenceStatus          => Result (signaled, unsignaled)
===> VkDevice, Vec<VkFence>                                                                                  | vkResetFences
===> VkDevice, Vec<VkFence>, waitAll, timeout                                                                | vkWaitForFences
===> VkDevice, VkFence                                                                                       | vkDestroyFence


typedef enum VkExternalFenceHandleTypeFlags {               typedef enum VkSemaphoreWaitFlags {             typedef enum VkFenceCreateFlags {
    VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT,                VK_SEMAPHORE_WAIT_ANY_BIT,                      VK_FENCE_CREATE_SIGNALED_BIT,
    VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT,         }                                               }
    VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT,     typedef enum VkEventCreateFlags {               typedef enum VkFenceImportFlagBits {
    VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT,                  VK_EVENT_CREATE_DEVICE_ONLY_BIT_KHR,            VK_FENCE_IMPORT_TEMPORARY_BIT
}                                                           }                                               }


Externally Synchronized Parameters
==================================

The instance parameter in vkDestroyInstance
The device parameter in vkDestroyDevice
The queue parameter in vkQueueSubmit
The fence parameter in vkQueueSubmit
The queue parameter in vkQueueWaitIdle
The memory parameter in vkFreeMemory
The memory parameter in vkMapMemory
The memory parameter in vkUnmapMemory
The buffer parameter in vkBindBufferMemory
The image parameter in vkBindImageMemory
The queue parameter in vkQueueBindSparse
The fence parameter in vkQueueBindSparse
The fence parameter in vkDestroyFence
The semaphore parameter in vkDestroySemaphore
The event parameter in vkDestroyEvent
The event parameter in vkSetEvent
The event parameter in vkResetEvent
The queryPool parameter in vkDestroyQueryPool
The buffer parameter in vkDestroyBuffer
The bufferView parameter in vkDestroyBufferView
The image parameter in vkDestroyImage
The imageView parameter in vkDestroyImageView
The shaderModule parameter in vkDestroyShaderModule
The pipelineCache parameter in vkDestroyPipelineCache
The dstCache parameter in vkMergePipelineCaches
The pipeline parameter in vkDestroyPipeline
The pipelineLayout parameter in vkDestroyPipelineLayout
The sampler parameter in vkDestroySampler
The descriptorSetLayout parameter in vkDestroyDescriptorSetLayout
The descriptorPool parameter in vkDestroyDescriptorPool
The descriptorPool parameter in vkResetDescriptorPool
The descriptorPool member of the pAllocateInfo parameter in vkAllocateDescriptorSets
The descriptorPool parameter in vkFreeDescriptorSets
The framebuffer parameter in vkDestroyFramebuffer
The renderPass parameter in vkDestroyRenderPass
The commandPool parameter in vkDestroyCommandPool
The commandPool parameter in vkResetCommandPool
The commandPool member of the pAllocateInfo parameter in vkAllocateCommandBuffers
The commandPool parameter in vkFreeCommandBuffers
The commandBuffer parameter in vkBeginCommandBuffer
The commandBuffer parameter in vkEndCommandBuffer
The commandBuffer parameter in vkResetCommandBuffer
The commandBuffer parameter in vkCmdBindPipeline
The commandBuffer parameter in vkCmdSetViewport
The commandBuffer parameter in vkCmdSetScissor
The commandBuffer parameter in vkCmdSetLineWidth
The commandBuffer parameter in vkCmdSetDepthBias
The commandBuffer parameter in vkCmdSetBlendConstants
The commandBuffer parameter in vkCmdSetDepthBounds
The commandBuffer parameter in vkCmdSetStencilCompareMask
The commandBuffer parameter in vkCmdSetStencilWriteMask
The commandBuffer parameter in vkCmdSetStencilReference
The commandBuffer parameter in vkCmdBindDescriptorSets
The commandBuffer parameter in vkCmdBindIndexBuffer
The commandBuffer parameter in vkCmdBindVertexBuffers
The commandBuffer parameter in vkCmdDraw
The commandBuffer parameter in vkCmdDrawIndexed
The commandBuffer parameter in vkCmdDrawIndirect
The commandBuffer parameter in vkCmdDrawIndexedIndirect
The commandBuffer parameter in vkCmdDispatch
The commandBuffer parameter in vkCmdDispatchIndirect
The commandBuffer parameter in vkCmdCopyBuffer
The commandBuffer parameter in vkCmdCopyImage
The commandBuffer parameter in vkCmdBlitImage
The commandBuffer parameter in vkCmdCopyBufferToImage
The commandBuffer parameter in vkCmdCopyImageToBuffer
The commandBuffer parameter in vkCmdUpdateBuffer
The commandBuffer parameter in vkCmdFillBuffer
The commandBuffer parameter in vkCmdClearColorImage
The commandBuffer parameter in vkCmdClearDepthStencilImage
The commandBuffer parameter in vkCmdClearAttachments
The commandBuffer parameter in vkCmdResolveImage
The commandBuffer parameter in vkCmdSetEvent
The commandBuffer parameter in vkCmdResetEvent
The commandBuffer parameter in vkCmdWaitEvents
The commandBuffer parameter in vkCmdPipelineBarrier
The commandBuffer parameter in vkCmdBeginQuery
The commandBuffer parameter in vkCmdEndQuery
The commandBuffer parameter in vkCmdResetQueryPool
The commandBuffer parameter in vkCmdWriteTimestamp
The commandBuffer parameter in vkCmdCopyQueryPoolResults
The commandBuffer parameter in vkCmdPushConstants
The commandBuffer parameter in vkCmdBeginRenderPass
The commandBuffer parameter in vkCmdNextSubpass
The commandBuffer parameter in vkCmdEndRenderPass
The commandBuffer parameter in vkCmdExecuteCommands
The commandBuffer parameter in vkCmdSetDeviceMask
The commandBuffer parameter in vkCmdDispatchBase
The commandPool parameter in vkTrimCommandPool
The ycbcrConversion parameter in vkDestroySamplerYcbcrConversion
The descriptorUpdateTemplate parameter in vkDestroyDescriptorUpdateTemplate
The descriptorSet parameter in vkUpdateDescriptorSetWithTemplate
The commandBuffer parameter in vkCmdDrawIndirectCount
The commandBuffer parameter in vkCmdDrawIndexedIndirectCount
The commandBuffer parameter in vkCmdBeginRenderPass2
The commandBuffer parameter in vkCmdNextSubpass2
The commandBuffer parameter in vkCmdEndRenderPass2
The surface parameter in vkDestroySurfaceKHR
The surface member of the pCreateInfo parameter in vkCreateSwapchainKHR
The oldSwapchain member of the pCreateInfo parameter in vkCreateSwapchainKHR
The swapchain parameter in vkDestroySwapchainKHR
The swapchain parameter in vkAcquireNextImageKHR
The semaphore parameter in vkAcquireNextImageKHR
The fence parameter in vkAcquireNextImageKHR
The queue parameter in vkQueuePresentKHR
The surface parameter in vkGetDeviceGroupSurfacePresentModesKHR
The surface parameter in vkGetPhysicalDevicePresentRectanglesKHR
The display parameter in vkCreateDisplayModeKHR
The mode parameter in vkGetDisplayPlaneCapabilitiesKHR
The commandBuffer parameter in vkCmdSetDeviceMaskKHR
The commandBuffer parameter in vkCmdDispatchBaseKHR
The commandPool parameter in vkTrimCommandPoolKHR
The commandBuffer parameter in vkCmdPushDescriptorSetKHR
The commandBuffer parameter in vkCmdPushDescriptorSetWithTemplateKHR
The descriptorUpdateTemplate parameter in vkDestroyDescriptorUpdateTemplateKHR
The descriptorSet parameter in vkUpdateDescriptorSetWithTemplateKHR
The commandBuffer parameter in vkCmdBeginRenderPass2KHR
The commandBuffer parameter in vkCmdNextSubpass2KHR
The commandBuffer parameter in vkCmdEndRenderPass2KHR
The swapchain parameter in vkGetSwapchainStatusKHR
The ycbcrConversion parameter in vkDestroySamplerYcbcrConversionKHR
The commandBuffer parameter in vkCmdDrawIndirectCountKHR
The commandBuffer parameter in vkCmdDrawIndexedIndirectCountKHR
The commandBuffer parameter in vkCmdSetFragmentShadingRateKHR
The swapchain parameter in vkWaitForPresentKHR
The operation parameter in vkDestroyDeferredOperationKHR
The commandBuffer parameter in vkCmdSetEvent2KHR
The commandBuffer parameter in vkCmdResetEvent2KHR
The commandBuffer parameter in vkCmdWaitEvents2KHR
The commandBuffer parameter in vkCmdPipelineBarrier2KHR
The commandBuffer parameter in vkCmdWriteTimestamp2KHR
The queue parameter in vkQueueSubmit2KHR
The fence parameter in vkQueueSubmit2KHR
The commandBuffer parameter in vkCmdWriteBufferMarker2AMD
The commandBuffer parameter in vkCmdCopyBuffer2KHR
The commandBuffer parameter in vkCmdCopyImage2KHR
The commandBuffer parameter in vkCmdCopyBufferToImage2KHR
The commandBuffer parameter in vkCmdCopyImageToBuffer2KHR
The commandBuffer parameter in vkCmdBlitImage2KHR
The commandBuffer parameter in vkCmdResolveImage2KHR
The accelerationStructure parameter in vkDestroyAccelerationStructureKHR
The commandBuffer parameter in vkCmdBuildAccelerationStructuresKHR
The commandBuffer parameter in vkCmdBuildAccelerationStructuresIndirectKHR
The commandBuffer parameter in vkCmdCopyAccelerationStructureKHR
The commandBuffer parameter in vkCmdCopyAccelerationStructureToMemoryKHR
The commandBuffer parameter in vkCmdCopyMemoryToAccelerationStructureKHR
The commandBuffer parameter in vkCmdWriteAccelerationStructuresPropertiesKHR
The commandBuffer parameter in vkCmdTraceRaysKHR
The commandBuffer parameter in vkCmdTraceRaysIndirectKHR
The commandBuffer parameter in vkCmdSetRayTracingPipelineStackSizeKHR

Externally Synchronized Parameter Lists
=======================================

The buffer member of each element of the pBufferBinds member of each element of the pBindInfo parameter in vkQueueBindSparse
The image member of each element of the pImageOpaqueBinds member of each element of the pBindInfo parameter in vkQueueBindSparse
The image member of each element of the pImageBinds member of each element of the pBindInfo parameter in vkQueueBindSparse
Each element of the pFences parameter in vkResetFences
Each element of the pDescriptorSets parameter in vkFreeDescriptorSets
The dstSet member of each element of the pDescriptorWrites parameter in vkUpdateDescriptorSets
The dstSet member of each element of the pDescriptorCopies parameter in vkUpdateDescriptorSets
Each element of the pCommandBuffers parameter in vkFreeCommandBuffers
Each element of the pWaitSemaphores member of the pPresentInfo parameter in vkQueuePresentKHR
Each element of the pSwapchains member of the pPresentInfo parameter in vkQueuePresentKHR
The surface member of each element of the pCreateInfos parameter in vkCreateSharedSwapchainsKHR
The oldSwapchain member of each element of the pCreateInfos parameter in vkCreateSharedSwapchainsKHR

Implicit Externally Synchronized Parameters
===========================================

All VkPhysicalDevice objects enumerated from instance in vkDestroyInstance
All VkQueue objects received from device in vkDestroyDevice
All VkQueue objects created from device in vkDeviceWaitIdle
Any VkDescriptorSet objects allocated from descriptorPool in vkResetDescriptorPool
The VkCommandPool that commandBuffer was allocated from in vkBeginCommandBuffer
The VkCommandPool that commandBuffer was allocated from in vkEndCommandBuffer
The VkCommandPool that commandBuffer was allocated from in vkResetCommandBuffer
The VkCommandPool that commandBuffer was allocated from, in vkCmdBindPipeline
The VkCommandPool that commandBuffer was allocated from, in vkCmdSetViewport
The VkCommandPool that commandBuffer was allocated from, in vkCmdSetScissor
The VkCommandPool that commandBuffer was allocated from, in vkCmdSetLineWidth
The VkCommandPool that commandBuffer was allocated from, in vkCmdSetDepthBias
The VkCommandPool that commandBuffer was allocated from, in vkCmdSetBlendConstants
The VkCommandPool that commandBuffer was allocated from, in vkCmdSetDepthBounds
The VkCommandPool that commandBuffer was allocated from, in vkCmdSetStencilCompareMask
The VkCommandPool that commandBuffer was allocated from, in vkCmdSetStencilWriteMask
The VkCommandPool that commandBuffer was allocated from, in vkCmdSetStencilReference
The VkCommandPool that commandBuffer was allocated from, in vkCmdBindDescriptorSets
The VkCommandPool that commandBuffer was allocated from, in vkCmdBindIndexBuffer
The VkCommandPool that commandBuffer was allocated from, in vkCmdBindVertexBuffers
The VkCommandPool that commandBuffer was allocated from, in vkCmdDraw
The VkCommandPool that commandBuffer was allocated from, in vkCmdDrawIndexed
The VkCommandPool that commandBuffer was allocated from, in vkCmdDrawIndirect
The VkCommandPool that commandBuffer was allocated from, in vkCmdDrawIndexedIndirect
The VkCommandPool that commandBuffer was allocated from, in vkCmdDispatch
The VkCommandPool that commandBuffer was allocated from, in vkCmdDispatchIndirect
The VkCommandPool that commandBuffer was allocated from, in vkCmdCopyBuffer
The VkCommandPool that commandBuffer was allocated from, in vkCmdCopyImage
The VkCommandPool that commandBuffer was allocated from, in vkCmdBlitImage
The VkCommandPool that commandBuffer was allocated from, in vkCmdCopyBufferToImage
The VkCommandPool that commandBuffer was allocated from, in vkCmdCopyImageToBuffer
The VkCommandPool that commandBuffer was allocated from, in vkCmdUpdateBuffer
The VkCommandPool that commandBuffer was allocated from, in vkCmdFillBuffer
The VkCommandPool that commandBuffer was allocated from, in vkCmdClearColorImage
The VkCommandPool that commandBuffer was allocated from, in vkCmdClearDepthStencilImage
The VkCommandPool that commandBuffer was allocated from, in vkCmdClearAttachments
The VkCommandPool that commandBuffer was allocated from, in vkCmdResolveImage
The VkCommandPool that commandBuffer was allocated from, in vkCmdSetEvent
The VkCommandPool that commandBuffer was allocated from, in vkCmdResetEvent
The VkCommandPool that commandBuffer was allocated from, in vkCmdWaitEvents
The VkCommandPool that commandBuffer was allocated from, in vkCmdPipelineBarrier
The VkCommandPool that commandBuffer was allocated from, in vkCmdBeginQuery
The VkCommandPool that commandBuffer was allocated from, in vkCmdEndQuery
The VkCommandPool that commandBuffer was allocated from, in vkCmdResetQueryPool
The VkCommandPool that commandBuffer was allocated from, in vkCmdWriteTimestamp
The VkCommandPool that commandBuffer was allocated from, in vkCmdCopyQueryPoolResults
The VkCommandPool that commandBuffer was allocated from, in vkCmdPushConstants
The VkCommandPool that commandBuffer was allocated from, in vkCmdBeginRenderPass
The VkCommandPool that commandBuffer was allocated from, in vkCmdNextSubpass
The VkCommandPool that commandBuffer was allocated from, in vkCmdEndRenderPass
The VkCommandPool that commandBuffer was allocated from, in vkCmdExecuteCommands
The VkCommandPool that commandBuffer was allocated from, in vkCmdSetDeviceMask
The VkCommandPool that commandBuffer was allocated from, in vkCmdDispatchBase
The VkCommandPool that commandBuffer was allocated from, in vkCmdDrawIndirectCount
The VkCommandPool that commandBuffer was allocated from, in vkCmdDrawIndexedIndirectCount
The VkCommandPool that commandBuffer was allocated from, in vkCmdBeginRenderPass2
The VkCommandPool that commandBuffer was allocated from, in vkCmdNextSubpass2
The VkCommandPool that commandBuffer was allocated from, in vkCmdEndRenderPass2
The VkCommandPool that commandBuffer was allocated from, in vkCmdBeginVideoCodingKHR
The VkCommandPool that commandBuffer was allocated from, in vkCmdEndVideoCodingKHR
The VkCommandPool that commandBuffer was allocated from, in vkCmdControlVideoCodingKHR
The VkCommandPool that commandBuffer was allocated from, in vkCmdDecodeVideoKHR
The VkCommandPool that commandBuffer was allocated from, in vkCmdSetDeviceMaskKHR
The VkCommandPool that commandBuffer was allocated from, in vkCmdDispatchBaseKHR
The VkCommandPool that commandBuffer was allocated from, in vkCmdPushDescriptorSetKHR
The VkCommandPool that commandBuffer was allocated from, in vkCmdPushDescriptorSetWithTemplateKHR
The VkCommandPool that commandBuffer was allocated from, in vkCmdBeginRenderPass2KHR
The VkCommandPool that commandBuffer was allocated from, in vkCmdNextSubpass2KHR
The VkCommandPool that commandBuffer was allocated from, in vkCmdEndRenderPass2KHR
The VkCommandPool that commandBuffer was allocated from, in vkCmdDrawIndirectCountKHR
The VkCommandPool that commandBuffer was allocated from, in vkCmdDrawIndexedIndirectCountKHR
The VkCommandPool that commandBuffer was allocated from, in vkCmdSetFragmentShadingRateKHR
The VkCommandPool that commandBuffer was allocated from, in vkCmdEncodeVideoKHR
The VkCommandPool that commandBuffer was allocated from, in vkCmdSetEvent2KHR
The VkCommandPool that commandBuffer was allocated from, in vkCmdResetEvent2KHR
The VkCommandPool that commandBuffer was allocated from, in vkCmdWaitEvents2KHR
The VkCommandPool that commandBuffer was allocated from, in vkCmdPipelineBarrier2KHR
The VkCommandPool that commandBuffer was allocated from, in vkCmdWriteTimestamp2KHR
The VkCommandPool that commandBuffer was allocated from, in vkCmdWriteBufferMarker2AMD
The VkCommandPool that commandBuffer was allocated from, in vkCmdCopyBuffer2KHR
The VkCommandPool that commandBuffer was allocated from, in vkCmdCopyImage2KHR
The VkCommandPool that commandBuffer was allocated from, in vkCmdCopyBufferToImage2KHR
The VkCommandPool that commandBuffer was allocated from, in vkCmdCopyImageToBuffer2KHR
The VkCommandPool that commandBuffer was allocated from, in vkCmdBlitImage2KHR
The VkCommandPool that commandBuffer was allocated from, in vkCmdResolveImage2KHR
The VkCommandPool that commandBuffer was allocated from, in vkCmdBuildAccelerationStructuresKHR
The VkCommandPool that commandBuffer was allocated from, in vkCmdBuildAccelerationStructuresIndirectKHR
The VkCommandPool that commandBuffer was allocated from, in vkCmdCopyAccelerationStructureKHR
The VkCommandPool that commandBuffer was allocated from, in vkCmdCopyAccelerationStructureToMemoryKHR
The VkCommandPool that commandBuffer was allocated from, in vkCmdCopyMemoryToAccelerationStructureKHR
The VkCommandPool that commandBuffer was allocated from, in vkCmdWriteAccelerationStructuresPropertiesKHR
The VkCommandPool that commandBuffer was allocated from, in vkCmdTraceRaysKHR
The VkCommandPool that commandBuffer was allocated from, in vkCmdTraceRaysIndirectKHR
The VkCommandPool that commandBuffer was allocated from, in vkCmdSetRayTracingPipelineStackSizeKHR


------------------

vkDestroyBuffer
vkDestroyBufferView
vkDestroyCommandPool
vkDestroyDescriptorPool
vkDestroyDescriptorSetLayout
vkDestroyDescriptorUpdateTemplate
vkDestroyDescriptorUpdateTemplateKHR
vkDestroyDevice
vkDestroyFramebuffer
vkDestroyImage
vkDestroyImageView
vkDestroyInstance
vkDestroyPipeline
vkDestroyPipelineCache
vkDestroyPipelineLayout
vkDestroyQueryPool
vkDestroyRenderPass
vkDestroySampler
vkDestroySemaphore
vkDestroyShaderModule
vkDestroySurfaceKHR
vkDestroySwapchainKHR

vkCreateDeferredOperationKHR
vkDeferredOperationJoinKHR
vkDestroyDeferredOperationKHR
vkGetDeferredOperationMaxConcurrencyKHR
vkGetDeferredOperationResultKHR

