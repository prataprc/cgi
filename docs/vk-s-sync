Implicit ordering guarantees                Fences, Sempahores, Events, Pipeline-barriers, Renderpasses
Explicit synchronisation primitives
Semaphore wait operation                    Synchronization commands introduce explicit execution dependencies, and memory dependencies between
Semaphore signal operation                  two sets of operations defined by the commandâ€™s two synchronization scopes.
Fence wait operation
Fence signal operation

Submission order
Pipeline order
Rasterization order

A memory dependency is an execution dependency which includes availability and visibility operations such that:
* The first set of operations happens-before the availability operation.
* The availability operation happens-before the visibility operation.
* The visibility operation happens-before the second set of operations.

Image subresources can be transitioned from one layout to another as part of a memory dependency


===== Memory Barrier

void vkCmdPipelineBarrier(
    VkCommandBuffer                 commandBuffer,
    VkPipelineStageFlagBits         srcStageMask,
    VkPipelineStageFlagBits         dstStageMask,
    VkDependencyFlags               dependencyFlags,
    uint32_t                        memoryBarrierCount,
    const VkMemoryBarrier*          pMemoryBarriers,
    uint32_t                        bufferMemoryBarrierCount,
    const VkBufferMemoryBarrier*    pBufferMemoryBarriers,
    uint32_t                        imageMemoryBarrierCount,
    const VkImageMemoryBarrier*     pImageMemoryBarriers);

typedef struct VkMemoryBarrier {                            typedef struct VkImageSubresourceRange {
    VkStructureType    sType;                                   VkImageAspectFlagBits aspectMask;
    const void*        pNext;                                   uint32_t              baseMipLevel;
    VkAccessFlagBits   srcAccessMask;                           uint32_t              levelCount;
    VkAccessFlagBits   dstAccessMask;                           uint32_t              baseArrayLayer;
}                                                               uint32_t              layerCount;
                                                            }
typedef struct VkBufferMemoryBarrier {
    VkStructureType    sType;                               typedef enum VkAccessFlagBits {
    const void*        pNext;                                   VK_ACCESS_INDIRECT_COMMAND_READ_BIT,
    VkAccessFlagBits   srcAccessMask;                           VK_ACCESS_INDEX_READ_BIT,
    VkAccessFlagBits   dstAccessMask;                           VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT,
    uint32_t           srcQueueFamilyIndex;                     VK_ACCESS_UNIFORM_READ_BIT,
    uint32_t           dstQueueFamilyIndex;                     VK_ACCESS_INPUT_ATTACHMENT_READ_BIT,
    VkBuffer           buffer;                                  VK_ACCESS_SHADER_READ_BIT,
    VkDeviceSize       offset;                                  VK_ACCESS_SHADER_WRITE_BIT,
    VkDeviceSize       size;                                    VK_ACCESS_COLOR_ATTACHMENT_READ_BIT,
}                                                               VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT,
                                                                VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT,
typedef struct VkImageMemoryBarrier {                           VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT,
    VkStructureType            sType;                           VK_ACCESS_TRANSFER_READ_BIT,
    const void*                pNext;                           VK_ACCESS_TRANSFER_WRITE_BIT,
    VkAccessFlagBits           srcAccessMask;                   VK_ACCESS_HOST_READ_BIT,
    VkAccessFlagBits           dstAccessMask;                   VK_ACCESS_HOST_WRITE_BIT,
    VkImageLayout              oldLayout;                       VK_ACCESS_MEMORY_READ_BIT,
    VkImageLayout              newLayout;                       VK_ACCESS_MEMORY_WRITE_BIT,
    uint32_t                   srcQueueFamilyIndex;             VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR,
    uint32_t                   dstQueueFamilyIndex;             VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR,
    VkImage                    image;                           VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR,
    VkImageSubresourceRange    subresourceRange;                VK_ACCESS_NONE_KHR,
}                                                           }


===== VkEvent

* Synchronization primitive used to insert a fine-grained dependency between commands submitted to the same queue, or between the host and a queue.

VkResult vkCreateEvent(                             typedef struct VkEventCreateInfo {      typedef enum VkEventCreateFlagBits {
    VkDevice                      device,               VkStructureType       sType;            VK_EVENT_CREATE_DEVICE_ONLY_BIT_KHR = 0x00000001,
    const VkEventCreateInfo*      pCreateInfo,          const void*           pNext;        }
    const VkAllocationCallbacks*  pAllocator,           VkEventCreateFlagBits flags;
    VkEvent*                      pEvent);          }

VkResult vkResetEvent(
    VkDevice                      device,
    VkEvent                       event);

VkResult vkSetEvent(
    VkDevice                      device,
    VkEvent                       event);

VkResult vkGetEventStatus(
    VkDevice                      device,
    VkEvent                       event);

void vkDestroyEvent(
    VkDevice                      device,
    VkEvent                       event,
    const VkAllocationCallbacks*  pAllocator);



void vkCmdResetEvent(
    VkCommandBuffer               commandBuffer,
    VkEvent                       event,
    VkPipelineStageFlagBits       stageMask);

void vkCmdSetEvent(
    VkCommandBuffer               commandBuffer,
    VkEvent                       event,
    VkPipelineStageFlagBits       stageMask);

void vkCmdWaitEvents(
    VkCommandBuffer               commandBuffer,
    uint32_t                      eventCount,
    const VkEvent*                pEvents,
    VkPipelineStageFlagBits       srcStageMask,
    VkPipelineStageFlagBits       dstStageMask,
    uint32_t                      memoryBarrierCount,
    const VkMemoryBarrier*        pMemoryBarriers,
    uint32_t                      bufferMemoryBarrierCount,
    const VkBufferMemoryBarrier*  pBufferMemoryBarriers,
    uint32_t                      imageMemoryBarrierCount,
    const VkImageMemoryBarrier*   pImageMemoryBarriers);

===== Appendix

typedef enum VkPipelineStageFlagBits {
    VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT,
    VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT,
    VK_PIPELINE_STAGE_VERTEX_INPUT_BIT,
    VK_PIPELINE_STAGE_VERTEX_SHADER_BIT,
    VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT,
    VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT,
    VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT,
    VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT,
    VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT,
    VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT,
    VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT,
    VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,
    VK_PIPELINE_STAGE_TRANSFER_BIT,
    VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT,
    VK_PIPELINE_STAGE_HOST_BIT,
    VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT,
    VK_PIPELINE_STAGE_ALL_COMMANDS_BIT,
    VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR,
    VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR,
    VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR,
    VK_PIPELINE_STAGE_NONE_KHR,
} VkPipelineStageFlagBits;
