===== VkInstance

VkResult vkCreateInstance(
    const VkInstanceCreateInfo*   pCreateInfo,      typedef struct VkInstanceCreateInfo {                       typedef struct VkApplicationInfo {
    const VkAllocationCallbacks*  pAllocator,           const VkApplicationInfo*    pApplicationInfo;               VkStructureType    sType;
    VkInstance*                   pInstance);           uint32_t                    enabledLayerCount;              const void*        pNext;
                                                        const char* const*          ppEnabledLayerNames;            const char*        pApplicationName;
 PFN_vkVoidFunction vkGetInstanceProcAddr(              uint32_t                    enabledExtensionCount;          uint32_t           applicationVersion;
     VkInstance    instance,                            const char* const*          ppEnabledExtensionNames;        const char*        pEngineName;
     const char*   pName);                          }                                                               uint32_t           engineVersion; 
                                                                                                                    uint32_t           apiVersion;
 VkResult vkEnumeratePhysicalDevices(                                                                           }
     VkInstance          instance,
     uint32_t*           pPhysicalDeviceCount,
     VkPhysicalDevice*   pPhysicalDevices);

 VkResult vkEnumerateInstanceLayerProperties(        typedef struct VkLayerProperties {
     uint32_t*           pPropertyCount,                 char        layerName[VK_MAX_EXTENSION_NAME_SIZE];
     VkLayerProperties*  pProperties);                   uint32_t    specVersion;
                                                         uint32_t    implementationVersion;
                                                         char        description[VK_MAX_DESCRIPTION_SIZE];
                                                     }
 VkResult vkEnumerateInstanceExtensionProperties(    typedef struct VkExtensionProperties {
     const char*               pLayerName,               char        extensionName[VK_MAX_EXTENSION_NAME_SIZE];
     uint32_t*                 pPropertyCount,           uint32_t    specVersion;
     VkExtensionProperties*    pProperties);         }


===== VkPhysicalDevice

* Vulkan separates the concept of physical and logical devices.
* Layers and extensions.
* Display, DisplayMode, DisplayPlane, DisplayCapabilities, DisplayProperties.

VkResult vkEnumerateDeviceExtensionProperties(
    VkPhysicalDevice        physicalDevice,
    const char*             pLayerName,
    uint32_t*               pPropertyCount,
    VkExtensionProperties*  pProperties);

VkResult vkEnumerateDeviceLayerProperties(
    VkPhysicalDevice        physicalDevice,
    uint32_t*               pPropertyCount,
    VkLayerProperties*      pProperties);

void vkGetPhysicalDeviceFeatures(                               typedef struct VkPhysicalDeviceProperties {
    VkPhysicalDevice            physicalDevice,                     uint32_t                          apiVersion;
    VkPhysicalDeviceFeatures*   pFeatures);                         uint32_t                          driverVersion;
void vkGetPhysicalDeviceFeatures2KHR(                               uint32_t                          vendorID;
    VkPhysicalDevice            physicalDevice,                     uint32_t                          deviceID;
    VkPhysicalDeviceFeatures2*  pFeatures);                         VkPhysicalDeviceType              deviceType;
void vkGetPhysicalDeviceProperties(                                 char                              deviceName[VK_MAX_PHYSICAL_DEVICE_NAME_SIZE];
    VkPhysicalDevice            physicalDevice,                     uint8_t                           pipelineCacheUUID[VK_UUID_SIZE];
    VkPhysicalDeviceProperties* pProperties);                       VkPhysicalDeviceLimits            limits;
                                                                    VkPhysicalDeviceSparseProperties  sparseProperties;
                                                                }
void vkGetPhysicalDeviceMemoryProperties(                       typedef struct VkPhysicalDeviceMemoryProperties {           typedef enum VkQueueFlagBits {
    VkPhysicalDevice                    physicalDevice,             uint32_t        memoryTypeCount;                            VK_QUEUE_GRAPHICS_BIT,
    VkPhysicalDeviceMemoryProperties*   pMemoryProperties);         VkMemoryType    memoryTypes[VK_MAX_MEMORY_TYPES];           VK_QUEUE_COMPUTE_BIT,
                                                                    uint32_t        memoryHeapCount;                            VK_QUEUE_TRANSFER_BIT,
                                                                    VkMemoryHeap    memoryHeaps[VK_MAX_MEMORY_HEAPS];           VK_QUEUE_SPARSE_BINDING_BIT,
                                                                }                                                               VK_QUEUE_PROTECTED_BIT,
                                                                                                                                VK_QUEUE_VIDEO_DECODE_BIT_KHR,
void vkGetPhysicalDeviceQueueFamilyProperties(                  typedef struct VkQueueFamilyProperties {                        VK_QUEUE_VIDEO_ENCODE_BIT_KHR,
    VkPhysicalDevice            physicalDevice,                     VkQueueFlagBits queueFlags;                             }
    uint32_t*                   pQueueFamilyPropertyCount,          uint32_t        queueCount;
    VkQueueFamilyProperties*    pQueueFamilyProperties);            uint32_t        timestampValidBits;
                                                                    VkExtent3D      minImageTransferGranularity;
                                                                }

void vkGetPhysicalDeviceFormatProperties(                       typedef struct VkFormatProperties {
    VkPhysicalDevice        physicalDevice,                         VkFormatFeatureFlags    linearTilingFeatures;
    VkFormat                format,                                 VkFormatFeatureFlags    optimalTilingFeatures;
    VkFormatProperties*     pFormatProperties);                     VkFormatFeatureFlags    bufferFeatures;
                                                                }

// TODO: Query ImageFormatProperties.

===== VkSurface

* Surface is created using Instance and platform specific surface constructor and parameters.
* Surface can be created directly from display (monitor) bypassing WSI.
* Headless surface can be created, which is essentially a no-op.
* Check whether the surface is supported by the choosen queue family of a physical device.

vkGetPhysicalDeviceSurfaceSupportKHR (per queue-family)


vkGetPhysicalDeviceSurfacePresentModesKHR               vkGetPhysicalDeviceSurfaceCapabilitiesKHR,
typedef enum VkPresentModeKHR {                         typedef struct VkSurfaceCapabilitiesKHR {                  typedef enum VkSurfaceTransformFlagBitsKHR {
    VK_PRESENT_MODE_IMMEDIATE_KHR,                          uint32_t                       minImageCount;                 VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR,
    VK_PRESENT_MODE_MAILBOX_KHR,                            uint32_t                       maxImageCount;                 VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR,
    VK_PRESENT_MODE_FIFO_KHR,                               VkExtent2D                     currentExtent;                 VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR,
    VK_PRESENT_MODE_FIFO_RELAXED_KHR,                       VkExtent2D                     minImageExtent;                VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR,
    VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR,              VkExtent2D                     maxImageExtent;                VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR,
    VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR,          uint32_t                       maxImageArrayLayers;           VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR,
};                                                          VkSurfaceTransformFlagBitsKHR  supportedTransforms;           VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR,
                                                            VkSurfaceTransformFlagBitsKHR  currentTransform;              VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR,
vkGetPhysicalDeviceSurfaceFormatsKHR                        VkCompositeAlphaFlagsKHR       supportedCompositeAlpha;       VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR,
typedef struct VkSurfaceFormatKHR {                         VkImageUsageFlagBits           supportedUsageFlags;       }
    VkFormat           format;                          }
    VkColorSpaceKHR    colorSpace;                      typedef enum VkCompositeAlphaFlagBitsKHR {                 typedef enum VkImageUsageFlagBits {
}                                                           VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR,                         VK_IMAGE_USAGE_TRANSFER_SRC_BIT,
typedef enum VkColorSpaceKHR {                              VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR,                 VK_IMAGE_USAGE_TRANSFER_DST_BIT,
    VK_COLOR_SPACE_SRGB_NONLINEAR_KHR,                      VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR,                VK_IMAGE_USAGE_SAMPLED_BIT,
    VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT,                VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR,                        VK_IMAGE_USAGE_STORAGE_BIT,
    VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT,            }                                                              VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT,         (FB)
    VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT,                                                                              VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, (FB)
    VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT,                                                                               VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT,
    VK_COLOR_SPACE_BT709_LINEAR_EXT,                                                                                   VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT,         (FB)
    VK_COLOR_SPACE_BT709_NONLINEAR_EXT,                                                                                VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR,
    VK_COLOR_SPACE_BT2020_LINEAR_EXT,                                                                                  VK_IMAGE_USAGE_VIDEO_DECODE_SRC_BIT_KHR,
    VK_COLOR_SPACE_HDR10_ST2084_EXT,                                                                                   VK_IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR,
    VK_COLOR_SPACE_DOLBYVISION_EXT,                                                                                    VK_IMAGE_USAGE_VIDEO_ENCODE_DST_BIT_KHR,
    VK_COLOR_SPACE_HDR10_HLG_EXT,                                                                                      VK_IMAGE_USAGE_VIDEO_ENCODE_SRC_BIT_KHR,
    VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT,                                                                                VK_IMAGE_USAGE_VIDEO_ENCODE_DPB_BIT_KHR,
    VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT,                                                                             VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV,
    VK_COLOR_SPACE_PASS_THROUGH_EXT,                                                                                   VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT,
    VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT,                                                                    }
    VK_COLOR_SPACE_DISPLAY_NATIVE_AMD,
}


===== VkSwapchain

VkResult vkCreateSwapchainKHR(
    VkDevice                                    device,
    const VkSwapchainCreateInfoKHR*             pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkSwapchainKHR*                             pSwapchain);

typedef struct VkSwapchainCreateInfoKHR {                                    typedef struct VkImageCreateInfo {
    VkStructureType                  sType;                                    * VkImageCreateFlagBits    flags;               typedef enum VkImageCreateFlagBits {
    const void*                      pNext;                                    * VkImageType              imageType;               VK_IMAGE_CREATE_SPARSE_BINDING_BIT,
    VkSwapchainCreateFlagsKHR        flags;                                      VkFormat                 format;                  VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT,
    VkSurfaceKHR                     surface;                                    VkExtent3D               extent;                  VK_IMAGE_CREATE_SPARSE_ALIASED_BIT,
    uint32_t                         minImageCount;                            * uint32_t                 mipLevels;               VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT,
                                                                                 uint32_t                 arrayLayers;             VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT,
    VkSurfaceTransformFlagBitsKHR    preTransform;    (VkSurface)              * VkSampleCountFlagBits    samples;                 VK_IMAGE_CREATE_ALIAS_BIT,
    VkCompositeAlphaFlagBitsKHR      compositeAlpha;  (VkSurface)              * VkImageTiling            tiling;                  VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT,
    VkColorSpaceKHR                  imageColorSpace; (VkSurface)                VkImageUsageFlagBits     usage;                   VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT,
    VkPresentModeKHR                 presentMode;     (VkSurface)                VkSharingMode            sharingMode;             VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT,
                                                                                 uint32_t                 queueFamilyIndexCount;   VK_IMAGE_CREATE_EXTENDED_USAGE_BIT,
    VkFormat                         imageFormat;     (VkSurface, VkImage)       const uint32_t*          pQueueFamilyIndices;     VK_IMAGE_CREATE_PROTECTED_BIT,
    VkExtent2D                       imageExtent;     (VkSurface, VkImage)     * VkImageLayout            initialLayout;           VK_IMAGE_CREATE_DISJOINT_BIT,
    uint32_t                         imageArrayLayers;(VkSurface, VkImage)   } VkImageCreateInfo;                                  VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR,
    VkImageUsageFlagBits             imageUsage;      (VkSurface, VkImage)                                                         VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR,
    VkSharingMode                    imageSharingMode;      (VkImage)        typedef enum VkSharingMode {                          VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR,
    uint32_t                         queueFamilyIndexCount; (VkImage)            VK_SHARING_MODE_EXCLUSIVE = 0,                    VK_IMAGE_CREATE_EXTENDED_USAGE_BIT_KHR,
    const uint32_t*                  pQueueFamilyIndices;   (VkImage)            VK_SHARING_MODE_CONCURRENT = 1,                   VK_IMAGE_CREATE_DISJOINT_BIT_KHR,
                                                                             }                                                     VK_IMAGE_CREATE_ALIAS_BIT_KHR,
    VkBool32                         clipped;                                                                                  }
    VkSwapchainKHR                   oldSwapchain;                           typedef enum VkImageType {
}                                                                                VK_IMAGE_TYPE_1D,                             typedef enum VkSampleCountFlagBits {
typedef enum VkSwapchainCreateFlagsKHR {                                         VK_IMAGE_TYPE_2D,                                 VK_SAMPLE_COUNT_1_BIT,
    VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR,                     VK_IMAGE_TYPE_3D,                                 VK_SAMPLE_COUNT_2_BIT,
    VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR,                                   }                                                     VK_SAMPLE_COUNT_4_BIT,
    VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR,                              typedef enum VkImageTiling {                          VK_SAMPLE_COUNT_8_BIT,
}                                                                                VK_IMAGE_TILING_OPTIMAL,                          VK_SAMPLE_COUNT_16_BIT,
                                                                                 VK_IMAGE_TILING_LINEAR,                           VK_SAMPLE_COUNT_32_BIT,
typedef struct VkDisplayModeParametersKHR {                                  }                                                     VK_SAMPLE_COUNT_64_BIT,
    VkExtent2D    visibleRegion;                                                                                               }
    uint32_t      refreshRate;
}

VkResult vkAcquireNextImageKHR(             typedef struct VkPresentInfoKHR {                       typedef enum VkImageLayout {
    VkDevice        device,                     VkStructureType          sType;                         VK_IMAGE_LAYOUT_UNDEFINED,
    VkSwapchainKHR  swapchain,                  const void*              pNext;                         VK_IMAGE_LAYOUT_GENERAL,
    uint64_t        timeout,                    uint32_t                 waitSemaphoreCount;            VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL,
    VkSemaphore     semaphore,                  const VkSemaphore*       pWaitSemaphores;               VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL,
    VkFence         fence,                      uint32_t                 swapchainCount;                VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL,
    uint32_t*       pImageIndex);               const VkSwapchainKHR*    pSwapchains;                   VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL,
                                                const uint32_t*          pImageIndices;                 VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,
VkResult vkGetSwapchainImagesKHR(               VkResult*                pResults;                      VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
    VkDevice        device,                 }                                                           VK_IMAGE_LAYOUT_PREINITIALIZED,
    VkSwapchainKHR  swapchain,              Extending VkBindImageMemoryInfoKHR.pNext                    VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL,
    uint32_t*       pSwapchainImageCount,   typedef struct VkBindImageMemorySwapchainInfoKHR {          VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL,
    VkImage*        pSwapchainImages);          VkStructureType    sType;                               VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMA,
                                                const void*        pNext;                               VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL,
                                                VkSwapchainKHR     swapchain;                           VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL,
                                                uint32_t           imageIndex;                          VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL,
                                            }                                                           VK_IMAGE_LAYOUT_PRESENT_SRC_KHR,
                                            Extending VkImageCreateInfoKHR.pNext                        VK_IMAGE_LAYOUT_VIDEO_DECODE_DST_KHR,
                                            typedef struct VkImageSwapchainCreateInfoKHR {              VK_IMAGE_LAYOUT_VIDEO_DECODE_SRC_KHR,
                                                VkStructureType    sType;                               VK_IMAGE_LAYOUT_VIDEO_DECODE_DPB_KHR,
                                                const void*        pNext;                               VK_IMAGE_LAYOUT_VIDEO_ENCODE_DST_KHR,
                                                VkSwapchainKHR     swapchain;                           VK_IMAGE_LAYOUT_VIDEO_ENCODE_SRC_KHR,
                                            }                                                           VK_IMAGE_LAYOUT_VIDEO_ENCODE_DPB_KHR,
                                                                                                        VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR,
                                                                                                        VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL_KHR,
                                                                                                        VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL_KHR,
                                                                                                    }

===== VkFramebuffer


Render passes operate in conjunction with framebuffers. Framebuffers represent a collection of specific memory attachments that a render pass instance uses.

VkResult vkCreateFramebuffer(                           typedef struct VkFramebufferCreateInfo {            typedef enum VkFramebufferCreateFlagBits {
    VkDevice                        device,                 VkStructureType             sType;                  VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT,
    const VkFramebufferCreateInfo*  pCreateInfo,            const void*                 pNext;              }
    const VkAllocationCallbacks*    pAllocator,             VkFramebufferCreateFlags    flags;
    VkFramebuffer*                  pFramebuffer);          VkRenderPass                renderPass;
                                                            uint32_t                    attachmentCount;
                                                            const VkImageView*          pAttachments;
                                                            uint32_t                    width;
                                                            uint32_t                    height;
                                                            uint32_t                    layers;
                                                        }




===== VkQueue

* Before an application can present an image, the image’s layout must be transitioned to the VK_IMAGE_LAYOUT_PRESENT_SRC_KHR layout,
  or for ashared presentable image the VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR layout.

VkQueue
  enum VkDeviceQueueCreateFlagBits {
    VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT
  }
  queue-family
  queue-index
  queue-priority

Before a fence or semaphore is signaled, it is guaranteed that any previously submitted queue operations have completed execution,
and that memory writes from those queue operations are available to future queue operations. Waiting on a signaled semaphore or
fence guarantees that previous writes that are available are also visible to subsequent commands.

void vkGetDeviceQueue(
    VkDevice     device,
    uint32_t     queueFamilyIndex,
    uint32_t     queueIndex,
    VkQueue*     pQueue);

VkResult vkQueuePresentKHR(                     typedef struct VkPresentInfoKHR {                   typedef struct VkSubmitInfo {
    VkQueue                  queue,                 VkStructureType          sType;                     VkStructureType                sType;
    const VkPresentInfoKHR*  pPresentInfo);         const void*              pNext;                     const void*                    pNext;
                                                    uint32_t                 waitSemaphoreCount;        uint32_t                       waitSemaphoreCount;
VkResult vkQueueSubmit(                             const VkSemaphore*       pWaitSemaphores;           const VkSemaphore*             pWaitSemaphores;
    VkQueue               queue,                    uint32_t                 swapchainCount;            const VkPipelineStageFlagBits* pWaitDstStageMask;
    uint32_t              submitCount,              const VkSwapchainKHR*    pSwapchains;               uint32_t                       commandBufferCount;
    const VkSubmitInfo*   pSubmits,                 const uint32_t*          pImageIndices;             const VkCommandBuffer*         pCommandBuffers;
    VkFence               fence);                   VkResult*                pResults;                  uint32_t                       signalSemaphoreCount;
                                                }                                                       const VkSemaphore*             pSignalSemaphores;
                                                                                                    }
VkResult vkQueueWaitIdle(VkQueue   queue);



===== VkDevice

typedef struct VkDeviceCreateInfo {
    VkStructureType                    sType;
    const void*                        pNext;
  x VkDeviceCreateFlags                flags;
    uint32_t                           queueCreateInfoCount;
    const VkDeviceQueueCreateInfo*     pQueueCreateInfos;
    uint32_t                           enabledLayerCount;
    const char* const*                 ppEnabledLayerNames;
    uint32_t                           enabledExtensionCount;
    const char* const*                 ppEnabledExtensionNames;
    const VkPhysicalDeviceFeatures*    pEnabledFeatures;
}
typedef struct VkDeviceQueueCreateInfo {                typedef enum VkDeviceQueueCreateFlagBits {
    VkStructureType             sType;                      VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT = 0x00000001,
    const void*                 pNext;                  }
  x VkDeviceQueueCreateFlags    flags;
    uint32_t                    queueFamilyIndex;
    uint32_t                    queueCount;
    const float*                pQueuePriorities;
}


===== VkDeviceMemory


VkResult vkAllocateMemory(                          typedef struct VkMemoryAllocateInfo {
    VkDevice                      device,               VkStructureType    sType;
    const VkMemoryAllocateInfo*   pAllocateInfo,        const void*        pNext;
    const VkAllocationCallbacks*  pAllocator,           VkDeviceSize       allocationSize;
    VkDeviceMemory*               pMemory);             uint32_t           memoryTypeIndex;
                                                    }

VkResult vkMapMemory(
    VkDevice            device,
    VkDeviceMemory      memory,
    VkDeviceSize        offset,
    VkDeviceSize        size,
  x VkMemoryMapFlags    flags,
    void**              ppData);


void vkUnmapMemory(
    VkDevice            device,
    VkDeviceMemory      memory);


VkResult vkFlushMappedMemoryRanges(                 typedef struct VkMappedMemoryRange {
    VkDevice                     device,                VkStructureType    sType;
    uint32_t                     memoryRangeCount,      const void*        pNext;
    const VkMappedMemoryRange*   pMemoryRanges);        VkDeviceMemory     memory;
                                                        VkDeviceSize       offset;
                                                        VkDeviceSize       size;
                                                    }

VkResult vkInvalidateMappedMemoryRanges(
    VkDevice                     device,
    uint32_t                     memoryRangeCount,
    const VkMappedMemoryRange*   pMemoryRanges);


VkResult vkBindBufferMemory(            VkResult vkBindBufferMemory2(                       typedef struct VkBindBufferMemoryInfo {
    VkDevice          device,               VkDevice                      device,               VkStructureType    sType;
    VkBuffer          buffer,               uint32_t                      bindInfoCount,        const void*        pNext;
    VkDeviceMemory    memory,               const VkBindBufferMemoryInfo* pBindInfos);          VkBuffer           buffer;
    VkDeviceSize      memoryOffset);                                                            VkDeviceMemory     memory;
                                                                                                VkDeviceSize       memoryOffset;
                                                                                            }
VkResult vkBindImageMemory(             VkResult vkBindImageMemory2(                        typedef struct VkBindImageMemoryInfo {
    VkDevice          device,               VkDevice                      device,               VkStructureType    sType;
    VkImage           image,                uint32_t                      bindInfoCount,        const void*        pNext;
    VkDeviceMemory    memory,               const VkBindImageMemoryInfo*  pBindInfos);          VkImage            image;
    VkDeviceSize      memoryOffset);                                                            VkDeviceMemory     memory;
                                                                                                VkDeviceSize       memoryOffset;
                                                                                            }
void vkFreeMemory(
    VkDevice                       evice,
    VkDeviceMemory                 emory,
    const VkAllocationCallbacks*   Allocator);


void vkGetBufferMemoryRequirements(                     void vkGetImageMemoryRequirements(                  typedef struct VkMemoryRequirements {
    VkDevice                device,                         VkDevice                device,                     VkDeviceSize    size;
    VkBuffer                buffer,                         VkImage                 image,                      VkDeviceSize    alignment;
    VkMemoryRequirements*   pMemoryRequirements);           VkMemoryRequirements*   pMemoryRequirements);       uint32_t        memoryTypeBits;
                                                                                                            }

void vkGetDeviceMemoryCommitment(
    VkDevice                device,
    VkDeviceMemory          memory,
    VkDeviceSize*           pCommittedMemoryInBytes);


uint64_t vkGetDeviceMemoryOpaqueCaptureAddress(             typedef struct VkDeviceMemoryOpaqueCaptureAddressInfo {
    VkDevice                                    device,         VkStructureType    sType;
    const VkDeviceMemoryOpaqueCaptureAddressInfo* pInfo);       const void*        pNext;
                                                                VkDeviceMemory     memory;
                                                            }

VkBufferMemoryBarrier
VkBufferMemoryBarrier2KHR
VkImageMemoryBarrier
VkImageMemoryBarrier2KHR
VkMemoryBarrier
VkMemoryBarrier2KHR

==== VkCommandPool


VkResult vkCreateCommandPool(                          typedef struct VkCommandPoolCreateInfo {             enum VkCommandPoolCreateFlagBits {
    VkDevice                        device,                VkCommandPoolCreateFlagBits flags;                   VK_COMMAND_POOL_CREATE_TRANSIENT_BIT,
    const VkCommandPoolCreateInfo*  pCreateInfo,           uint32_t                    queueFamilyIndex;        VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT,
    const VkAllocationCallbacks*    pAllocator,        }                                                        VK_COMMAND_POOL_CREATE_PROTECTED_BIT,
    VkCommandPool*                  pCommandPool);                                                          }


VkResult vkResetCommandPool(                        enum VkCommandPoolResetFlagBits {
    VkDevice                    device,                 VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT
    VkCommandPool               commandPool,        }
    VkCommandPoolResetFlagBits  flags);


void vkTrimCommandPool(
    VkDevice                    device,
    VkCommandPool               commandPool,
  x VkCommandPoolTrimFlagBits   flags);

void vkDestroyCommandPool(
    VkDevice                      device,
    VkCommandPool                 commandPool,
    const VkAllocationCallbacks*  pAllocator);


==== VkCommandBuffer

* Primary command buffers, which can execute secondary command buffers, and which are submitted to queues
* Secondary command buffers, which can be executed by primary command buffers, and which are not directly submitted to queues.
* Commands recorded in command buffers perform actions like draw,
   - dispatch
   - clear
   - copy,
   - query/timestamp operations
   - begin/end subpass operations
   - alter framebuffer attachments
   - read/write buffer or image memory
   - write to query pools.
   (set state)
   - bind pipelines
   - bind descriptor sets
   - bind buffers, set dynamic state
   - push constants
   - set render pass/subpass state.
  (perform synchronization)
   - set/wait events
   - pipeline barrier
   - render pass/subpass dependencies

* Each command buffer manages state independently of other command buffers.
* There is no inheritance of state across primary and secondary command buffers, or between secondary command buffers.
* All state of the primary command buffer is undefined after an execute secondary command buffer command is recorded.
* If the primary command buffer is inside a render pass instance, then the render pass and subpass state is not disturbed by executing secondary command buffers.


VkResult vkAllocateCommandBuffers(                          typedef struct VkCommandBufferAllocateInfo {            enum VkCommandBufferLevel {
    VkDevice                            device,                 VkCommandPool           commandPool;                    VK_COMMAND_BUFFER_LEVEL_PRIMARY,
    const VkCommandBufferAllocateInfo*  pAllocateInfo,          VkCommandBufferLevel    level;                          VK_COMMAND_BUFFER_LEVEL_SECONDARY,
    VkCommandBuffer*                    pCommandBuffers);       uint32_t                commandBufferCount;         }
                                                            }


VkResult vkResetCommandBuffer(                          typedef enum VkCommandBufferResetFlagBits {
    VkCommandBuffer                 commandBuffer,          VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT = 0x00000001,
    VkCommandBufferResetFlagBits    flags);             }


VkResult vkBeginCommandBuffer(                          typedef struct VkCommandBufferBeginInfo {                       typedef enum VkCommandBufferUsageFlagBits {
    VkCommandBuffer                  commandBuffer,         VkStructureType                          sType;                 VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT,
    const VkCommandBufferBeginInfo*  pBeginInfo);           const void*                              pNext;                 VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT,
                                                            VkCommandBufferUsageFlagBits             flags;                 VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT,
                                                            const VkCommandBufferInheritanceInfo*    pInheritanceInfo;  }
                                                        }
                                    typedef struct VkCommandBufferInheritanceInfo {             typedef enum VkQueryPipelineStatisticFlagBits {
                                        VkStructureType                  sType;                     VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT,
                                        const void*                      pNext;                     VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT,
                                        VkRenderPass                     renderPass;                VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT,
                                        uint32_t                         subpass;                   VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT,
                                        VkFramebuffer                    framebuffer;               VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT,
                                        VkBool32                         occlusionQueryEnable;      VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT,
                                        VkQueryControlFlagBits           queryFlags;                VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT,
                                        VkQueryPipelineStatisticFlagBits pipelineStatistics;        VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT,
                                    }                                                               VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT,
                                    typedef enum VkQueryControlFlagBits {                           VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT,
                                        VK_QUERY_CONTROL_PRECISE_BIT                                VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT,
                                    }                                                           }

VkResult vkEndCommandBuffer(VkCommandBuffer commandBuffer);

void vkCmdExecuteCommands(
    VkCommandBuffer            commandBuffer,
    uint32_t                   commandBufferCount,
    const VkCommandBuffer*     pCommandBuffers);

void vkFreeCommandBuffers(
    VkDevice                device,
    VkCommandPool           commandPool,
    uint32_t                commandBufferCount,
    const VkCommandBuffer*  pCommandBuffers);



===== VkBuffer


VkDeviceAddress vkGetBufferDeviceAddress(               typedef struct VkBufferDeviceAddressInfo {
    VkDevice                           device,              VkStructureType    sType;
    const VkBufferDeviceAddressInfo*   pInfo);              const void*        pNext;
                                                            VkBuffer           buffer;
                                                        }


VkResult vkCreateBuffer(                                typedef struct VkBufferCreateInfo {                         typedef enum VkBufferUsageFlagBits {
    VkDevice                           device,              VkStructureType        sType;                               VK_BUFFER_USAGE_TRANSFER_SRC_BIT,
    const VkBufferCreateInfo*          pCreateInfo,         const void*            pNext;                               VK_BUFFER_USAGE_TRANSFER_DST_BIT,
    const VkAllocationCallbacks*       pAllocator,          VkBufferCreateFlagBits flags;                               VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT,
    VkBuffer*                          pBuffer);            VkDeviceSize           size;                                VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT,
                                                            VkBufferUsageFlagBits  usage;                               VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT,
                                                            VkSharingMode          sharingMode;                         VK_BUFFER_USAGE_STORAGE_BUFFER_BIT,
                                                            uint32_t               queueFamilyIndexCount;               VK_BUFFER_USAGE_INDEX_BUFFER_BIT,
void vkDestroyBuffer(                                       const uint32_t*        pQueueFamilyIndices;                 VK_BUFFER_USAGE_VERTEX_BUFFER_BIT,
    VkDevice                            device,         }                                                               VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT,
    VkBuffer                            buffer,         typedef enum VkBufferCreateFlagBits {                           VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT,
    const VkAllocationCallbacks*        pAllocator);        VK_BUFFER_CREATE_SPARSE_BINDING_BIT,                    }
                                                            VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT,                  typedef enum VkSharingMode {
                                                            VK_BUFFER_CREATE_SPARSE_ALIASED_BIT,                        VK_SHARING_MODE_EXCLUSIVE,
                                                            VK_BUFFER_CREATE_PROTECTED_BIT,                             VK_SHARING_MODE_CONCURRENT,
                                                            VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT,     }
                                                        }

vkBindBufferMemory
vkBindBufferMemory2


void vkCmdBindVertexBuffers(
    VkCommandBuffer       commandBuffer,
    uint32_t              firstBinding,
    uint32_t              bindingCount,
    const VkBuffer*       pBuffers,
    const VkDeviceSize*   pOffsets);


void vkCmdBindIndexBuffer(                              typedef enum VkIndexType {
    VkCommandBuffer      commandBuffer,                     VK_INDEX_TYPE_UINT16,
    VkBuffer             buffer,                            VK_INDEX_TYPE_UINT32,
    VkDeviceSize         offset,                        } VkIndexType;
    VkIndexType          indexType);


void vkCmdCopyBuffer(                                   typedef struct VkBufferCopy {       typedef struct VkCopyBufferInfo2KHR {           typedef struct VkBufferCopy2KHR {
    VkCommandBuffer         commandBuffer,                  VkDeviceSize    srcOffset;          VkStructureType            sType;               VkStructureType    sType;
    VkBuffer                srcBuffer,                      VkDeviceSize    dstOffset;          const void*                pNext;               const void*        pNext;
    VkBuffer                dstBuffer,                      VkDeviceSize    size;               VkBuffer                   srcBuffer;           VkDeviceSize       srcOffset;
    uint32_t                regionCount,                }                                       VkBuffer                   dstBuffer;           VkDeviceSize       dstOffset;
    const VkBufferCopy*     pRegions);                                                          uint32_t                   regionCount;         VkDeviceSize       size;
                                                                                                const VkBufferCopy2KHR*    pRegions;        }
void vkCmdCopyBuffer2KHR(                                                                   }
    VkCommandBuffer              commandBuffer,
    const VkCopyBufferInfo2KHR*  pCopyBufferInfo);



void vkCmdCopyBufferToImage(                            typedef struct VkBufferImageCopy {                      typedef struct VkImageSubresourceLayers {
    VkCommandBuffer            commandBuffer,               VkDeviceSize                bufferOffset;               VkImageAspectFlagBits aspectMask;
    VkBuffer                   srcBuffer,                   uint32_t                    bufferRowLength;            uint32_t              mipLevel;
    VkImage                    dstImage,                    uint32_t                    bufferImageHeight;          uint32_t              baseArrayLayer;
    VkImageLayout              dstImageLayout,              VkImageSubresourceLayers    imageSubresource;           uint32_t              layerCount;
    uint32_t                   regionCount,                 VkOffset3D                  imageOffset;            }
    const VkBufferImageCopy*   pRegions);                   VkExtent3D                  imageExtent;
                                                        }
void vkCmdCopyBufferToImage2KHR(
    VkCommandBuffer                      commandBuffer,
    const VkCopyBufferToImageInfo2KHR*   pCopyBufferToImageInfo);


void vkCmdCopyImageToBuffer(
    VkCommandBuffer           commandBuffer,
    VkImage                   srcImage,
    VkImageLayout             srcImageLayout,
    VkBuffer                  dstBuffer,
    uint32_t                  regionCount,
    const VkBufferImageCopy*  pRegions);

void vkCmdCopyImageToBuffer2KHR(
    VkCommandBuffer                     commandBuffer,
    const VkCopyImageToBufferInfo2KHR*  pCopyImageToBufferInfo);

void vkCmdFillBuffer(
    VkCommandBuffer  commandBuffer,
    VkBuffer         dstBuffer,
    VkDeviceSize     dstOffset,
    VkDeviceSize     size,
    uint32_t         data);

void vkCmdUpdateBuffer(
    VkCommandBuffer  commandBuffer,
    VkBuffer         dstBuffer,
    VkDeviceSize     dstOffset,
    VkDeviceSize     dataSize,
    const void*      pData);


===== VkBufferView


VkResult vkCreateBufferView(                            typedef struct VkBufferViewCreateInfo {
    VkDevice                       device,                  VkStructureType            sType;
    const VkBufferViewCreateInfo*  pCreateInfo,             const void*                pNext;
    const VkAllocationCallbacks*   pAllocator,            x VkBufferViewCreateFlags    flags;
    VkBufferView*                  pView);                  VkBuffer                   buffer;
                                                            VkFormat                   format;
                                                            VkDeviceSize               offset;
                                                            VkDeviceSize               range;
                                                        }

void vkDestroyBufferView(
    VkDevice                       device,
    VkBufferView                   bufferView,
    const VkAllocationCallbacks*   pAllocator);



====== VkImage


VkResult vkCreateImage(                                 typedef struct VkImageCreateInfo {
    VkDevice                      device,                   VkStructureType          sType;
    const VkImageCreateInfo*      pCreateInfo,              const void*              pNext;
    const VkAllocationCallbacks*  pAllocator,               VkImageCreateFlagBits    flags;
    VkImage*                      pImage);                  VkImageType              imageType;
                                                            VkFormat                 format;
                                                            VkExtent3D               extent;
                                                            uint32_t                 mipLevels;
                                                            uint32_t                 arrayLayers;
                                                            VkSampleCountFlagBits    samples;
                                                            VkImageTiling            tiling;
                                                            VkImageUsageFlagBits     usage;
                                                            VkSharingMode            sharingMode;
                                                            uint32_t                 queueFamilyIndexCount;
                                                            const uint32_t*          pQueueFamilyIndices;
                                                            VkImageLayout            initialLayout;
                                                        }


void vkGetImageSubresourceLayout(                       typedef struct VkImageSubresource {             typedef struct VkSubresourceLayout {
    VkDevice                   device,                      VkImageAspectFlagBits aspectMask;               VkDeviceSize    offset;
    VkImage                    image,                       uint32_t              mipLevel;                 VkDeviceSize    size;
    const VkImageSubresource*  pSubresource,                uint32_t              arrayLayer;               VkDeviceSize    rowPitch;
    VkSubresourceLayout*       pLayout);                }                                                   VkDeviceSize    arrayPitch;
                                                                                                            VkDeviceSize    depthPitch;
                                                                                                        }

void vkDestroyImage(
    VkDevice                      device,
    VkImage                       image,
    const VkAllocationCallbacks*  pAllocator);


void vkCmdBlitImage(                                typedef struct VkImageBlit {                        typedef enum VkFilter {
    VkCommandBuffer        commandBuffer,               VkImageSubresourceLayers    srcSubresource;         VK_FILTER_NEAREST,
    VkImage                srcImage,                    VkOffset3D                  srcOffsets[2];          VK_FILTER_LINEAR,
    VkImageLayout          srcImageLayout,              VkImageSubresourceLayers    dstSubresource;         VK_FILTER_CUBIC_IMG,
    VkImage                dstImage,                    VkOffset3D                  dstOffsets[2];      }
    VkImageLayout          dstImageLayout,          }
    uint32_t               regionCount,
    const VkImageBlit*     pRegions,
    VkFilter               filter);


void vkCmdClearColorImage(                              typedef union VkClearColorValue {       typedef struct VkImageSubresourceRange {
    VkCommandBuffer                   commandBuffer,        float       float32[4];                 VkImageAspectFlagBits aspectMask;
    VkImage                           image,                int32_t     int32[4];                   uint32_t              baseMipLevel;
    VkImageLayout                     imageLayout,          uint32_t    uint32[4];                  uint32_t              levelCount;
    const VkClearColorValue*          pColor,           }                                           uint32_t              baseArrayLayer;
    uint32_t                          rangeCount,                                                   uint32_t              layerCount;
    const VkImageSubresourceRange*    pRanges);                                                 }


void vkCmdClearDepthStencilImage(                       typedef struct VkClearDepthStencilValue {
    VkCommandBuffer                   commandBuffer,        float       depth;
    VkImage                           image,                uint32_t    stencil;
    VkImageLayout                     imageLayout,      }
    const VkClearDepthStencilValue*   pDepthStencil,
    uint32_t                          rangeCount,
    const VkImageSubresourceRange*    pRanges);


void vkCmdCopyImage(                                        typedef struct VkImageCopy {
    VkCommandBuffer                   commandBuffer,            VkImageSubresourceLayers    srcSubresource;
    VkImage                           srcImage,                 VkOffset3D                  srcOffset;
    VkImageLayout                     srcImageLayout,           VkImageSubresourceLayers    dstSubresource;
    VkImage                           dstImage,                 VkOffset3D                  dstOffset;
    VkImageLayout                     dstImageLayout,           VkExtent3D                  extent;
    uint32_t                          regionCount,          }
    const VkImageCopy*                pRegions);


void vkCmdResolveImage(                                     typedef struct VkImageResolve {
    VkCommandBuffer                   commandBuffer,            VkImageSubresourceLayers    srcSubresource;
    VkImage                           srcImage,                 VkOffset3D                  srcOffset;
    VkImageLayout                     srcImageLayout,           VkImageSubresourceLayers    dstSubresource;
    VkImage                           dstImage,                 VkOffset3D                  dstOffset;
    VkImageLayout                     dstImageLayout,           VkExtent3D                  extent;
    uint32_t                          regionCount,          }
    const VkImageResolve*             pRegions);


===== VkImageView

VkResult vkCreateImageView(                                 typedef struct VkImageViewCreateInfo {                  typedef enum VkImageViewType {
    VkDevice                          device,                   VkStructureType            sType;                       VK_IMAGE_VIEW_TYPE_1D,
    const VkImageViewCreateInfo*      pCreateInfo,              const void*                pNext;                       VK_IMAGE_VIEW_TYPE_2D,
    const VkAllocationCallbacks*      pAllocator,             x VkImageViewCreateFlags     flags;                       VK_IMAGE_VIEW_TYPE_3D,
    VkImageView*                      pView);                   VkImage                    image;                       VK_IMAGE_VIEW_TYPE_CUBE,
                                                                VkImageViewType            viewType;                    VK_IMAGE_VIEW_TYPE_1D_ARRAY,
                                                                VkFormat                   format;                      VK_IMAGE_VIEW_TYPE_2D_ARRAY,
                                                                VkComponentMapping         components;                  VK_IMAGE_VIEW_TYPE_CUBE_ARRAY,
                                                                VkImageSubresourceRange    subresourceRange;        }
                                                            }                                                       typedef enum VkComponentSwizzle {
                                                            typedef struct VkComponentMapping {                         VK_COMPONENT_SWIZZLE_IDENTITY,
                                                                VkComponentSwizzle    r;                                VK_COMPONENT_SWIZZLE_ZERO,
                                                                VkComponentSwizzle    g;                                VK_COMPONENT_SWIZZLE_ONE,
                                                                VkComponentSwizzle    b;                                VK_COMPONENT_SWIZZLE_R,
                                                                VkComponentSwizzle    a;                                VK_COMPONENT_SWIZZLE_G,
                                                            }                                                           VK_COMPONENT_SWIZZLE_B,
                                                                                                                        VK_COMPONENT_SWIZZLE_A,
void vkDestroyImageView(                                                                                            }
    VkDevice                       device,
    VkImageView                    imageView,
    const VkAllocationCallbacks*   pAllocator);



===== VkSampler

VkResult vkCreateSampler(                           typedef struct VkSamplerCreateInfo {                        typedef enum VkFilter {
    VkDevice                       device,              VkStructureType         sType;                              VK_FILTER_NEAREST,
    const VkSamplerCreateInfo*     pCreateInfo,         const void*             pNext;                              VK_FILTER_LINEAR,
    const VkAllocationCallbacks*   pAllocator,        x VkSamplerCreateFlags    flags;                          }
    VkSampler*                     pSampler);           VkFilter                magFilter;                      typedef enum VkSamplerMipmapMode {
                                                        VkFilter                minFilter;                          VK_SAMPLER_MIPMAP_MODE_NEAREST,
                                                        VkSamplerMipmapMode     mipmapMode;                         VK_SAMPLER_MIPMAP_MODE_LINEAR,
                                                        VkSamplerAddressMode    addressModeU;                   }
                                                        VkSamplerAddressMode    addressModeV;                   typedef enum VkSamplerAddressMode {
                                                        VkSamplerAddressMode    addressModeW;                       VK_SAMPLER_ADDRESS_MODE_REPEAT,
                                                        float                   mipLodBias;                         VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT,
                                                        VkBool32                anisotropyEnable;                   VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE,
                                                        float                   maxAnisotropy;                      VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER,
                                                        VkBool32                compareEnable;                      VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE,
                                                        VkCompareOp             compareOp;                      }
                                                        float                   minLod;                         typedef enum VkCompareOp {
                                                        float                   maxLod;                             VK_COMPARE_OP_NEVER,
                                                        VkBorderColor           borderColor;                        VK_COMPARE_OP_LESS,
                                                        VkBool32                unnormalizedCoordinates;            VK_COMPARE_OP_EQUAL,
                                                    }                                                               VK_COMPARE_OP_LESS_OR_EQUAL,
                                                    typedef enum VkBorderColor {                                    VK_COMPARE_OP_GREATER,
                                                        VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK,                    VK_COMPARE_OP_NOT_EQUAL,
                                                        VK_BORDER_COLOR_INT_TRANSPARENT_BLACK,                      VK_COMPARE_OP_GREATER_OR_EQUAL,
                                                        VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK,                         VK_COMPARE_OP_ALWAYS,
                                                        VK_BORDER_COLOR_INT_OPAQUE_BLACK,                       }
                                                        VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE,
                                                        VK_BORDER_COLOR_INT_OPAQUE_WHITE,
                                                    }

void vkDestroySampler(
    VkDevice                       device,
    VkSampler                      sampler,
    const VkAllocationCallbacks*   pAllocator);



===== VkRenderPass


* The use of a render pass in a command buffer is a render pass instance.
* The subpasses in a render pass all render to the same dimensions.
* Fragments for pixel (x,y,layer) in one subpass can only read attachment contents written by previous subpasses at that same (x,y,layer) location.
* For multi-pixel fragments, the pixel read from an input attachment is selected from the pixels covered by that fragment in an implementation- dependent manner.
  However, this selection must be made consistently for any fragment with the same shading rate for the lifetime of the VkDevice.
* The specific image views that will be used for the attachments, and their dimensions, are specified in VkFramebuffer objects.
* Framebuffers are created with respect to a specific render pass that the framebuffer is compatible with
* Collectively, a render pass and a framebuffer define the complete render target state for one or more subpasses as well as the algorithmic dependencies between the subpasses.

VkResult vkCreateRenderPass(                        typedef struct VkRenderPassCreateInfo {                         typedef enum VkAttachmentDescriptionFlagBits {
    VkDevice                       device,            x VkRenderPassCreateFlags         flags;                          VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT,
    const VkRenderPassCreateInfo*  pCreateInfo,         uint32_t                        attachmentCount;            }
    const VkAllocationCallbacks*   pAllocator,          const VkAttachmentDescription*  pAttachments;               typedef enum VkAttachmentLoadOp {
    VkRenderPass*                  pRenderPass);        uint32_t                        subpassCount;                   VK_ATTACHMENT_LOAD_OP_LOAD,
                                                        const VkSubpassDescription*     pSubpasses;                     VK_ATTACHMENT_LOAD_OP_CLEAR,
                                                        uint32_t                        dependencyCount;                VK_ATTACHMENT_LOAD_OP_DONT_CARE,
                                                        const VkSubpassDependency*      pDependencies;              }
                                                    }                                                               typedef enum VkAttachmentStoreOp {
                                                    typedef struct VkAttachmentDescription {                            VK_ATTACHMENT_STORE_OP_STORE,
                                                        VkAttachmentDescriptionFlagBits flags;                          VK_ATTACHMENT_STORE_OP_DONT_CARE,
                                                        VkFormat                        format;                         VK_ATTACHMENT_STORE_OP_NONE_QCOM,
                                                        VkSampleCountFlagBits           samples;                    }
                                                        VkAttachmentLoadOp              loadOp;                     typedef enum VkSubpassDescriptionFlagBits {
                                                        VkAttachmentStoreOp             storeOp;                        VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX,
                                                        VkAttachmentLoadOp              stencilLoadOp;                  VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX,
                                                        VkAttachmentStoreOp             stencilStoreOp;                 VK_SUBPASS_DESCRIPTION_FRAGMENT_REGION_BIT_QCOM,
                                                        VkImageLayout                   initialLayout;                  VK_SUBPASS_DESCRIPTION_SHADER_RESOLVE_BIT_QCOM,
                                                        VkImageLayout                   finalLayout;                }
                                                    }                                                               typedef enum VkPipelineBindPoint {
                                                    typedef struct VkSubpassDescription {                               VK_PIPELINE_BIND_POINT_GRAPHICS,
                                                        VkSubpassDescriptionFlagBits  flags;                            VK_PIPELINE_BIND_POINT_COMPUTE,
                                                        VkPipelineBindPoint           pipelineBindPoint;                VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR,
                                                        uint32_t                      inputAttachmentCount;         }
                                                        const VkAttachmentReference*  pInputAttachments;
                                                        uint32_t                      colorAttachmentCount;         typedef enum VkDependencyFlagBits {
                                                        const VkAttachmentReference*  pColorAttachments;                VK_DEPENDENCY_BY_REGION_BIT,
                                                        const VkAttachmentReference*  pResolveAttachments;              VK_DEPENDENCY_DEVICE_GROUP_BIT,
                                                        const VkAttachmentReference*  pDepthStencilAttachment;          VK_DEPENDENCY_VIEW_LOCAL_BIT,
                                                        uint32_t                      preserveAttachmentCount;      }
                                                        const uint32_t*               pPreserveAttachments;         enum VkPipelineStageFlagBits {
                                                    }                                                                   VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT,
                                                    typedef struct VkSubpassDependency {                                VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT,
                                                        uint32_t                srcSubpass;                             VK_PIPELINE_STAGE_VERTEX_INPUT_BIT,
                                                        uint32_t                dstSubpass;                             VK_PIPELINE_STAGE_VERTEX_SHADER_BIT,
                                                        VkPipelineStageFlagBits srcStageMask;                           VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT,
                                                        VkPipelineStageFlagBits dstStageMask;                           VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT,
                                                        VkAccessFlagBits        srcAccessMask;                          VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT,
                                                        VkAccessFlagBits        dstAccessMask;                          VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT,
                                                        VkDependencyFlagBits    dependencyFlags;                        VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT,
                                                    }                                                                   VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT,
                                                    typedef struct VkAttachmentReference {                              VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT,
                                                        uint32_t         attachment;                                    VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,
                                                        VkImageLayout    layout;                                        VK_PIPELINE_STAGE_TRANSFER_BIT,
                                                    }                                                                   VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT,
                                                     typedef enum VkAccessFlagBits {                                    VK_PIPELINE_STAGE_HOST_BIT,
                                                         VK_ACCESS_INDIRECT_COMMAND_READ_BIT,                           VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT,
                                                         VK_ACCESS_INDEX_READ_BIT,                                      VK_PIPELINE_STAGE_ALL_COMMANDS_BIT,
                                                         VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT,                           VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT,
                                                         VK_ACCESS_UNIFORM_READ_BIT,                                    VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT,
                                                         VK_ACCESS_INPUT_ATTACHMENT_READ_BIT,                           VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR,
                                                         VK_ACCESS_SHADER_READ_BIT,                                     VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR,
                                                         VK_ACCESS_SHADER_WRITE_BIT,                                    VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV,
                                                         VK_ACCESS_COLOR_ATTACHMENT_READ_BIT,                           VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV,
                                                         VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT,                          VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV,
                                                         VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT,                   VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT,
                                                         VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT,                  VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_NV,
                                                         VK_ACCESS_TRANSFER_READ_BIT,                                   VK_PIPELINE_STAGE_NONE_KHR,
                                                         VK_ACCESS_TRANSFER_WRITE_BIT,                              }
                                                         VK_ACCESS_HOST_READ_BIT,
                                                         VK_ACCESS_HOST_WRITE_BIT,
                                                         VK_ACCESS_MEMORY_READ_BIT,
                                                         VK_ACCESS_MEMORY_WRITE_BIT,
                                                         VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT,
                                                         VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT,
                                                         VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT,
                                                         VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT,
                                                         VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT,
                                                         VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR,
                                                         VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR,
                                                         VK_ACCESS_SHADING_RATE_IMAGE_READ_BIT_NV,
                                                         VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT,
                                                         VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_NV,
                                                         VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_NV,
                                                         VK_ACCESS_NONE_KHR,
                                                     }

void vkGetRenderAreaGranularity(
    VkDevice       device,
    VkRenderPass   renderPass,
    VkExtent2D*    pGranularity);


void vkCmdBeginRenderPass(                              typedef struct VkRenderPassBeginInfo {          typedef union VkClearValue {
    VkCommandBuffer                 commandBuffer,          VkStructureType        sType;                   VkClearColorValue           color;
    const VkRenderPassBeginInfo*    pRenderPassBegin,       const void*            pNext;                   VkClearDepthStencilValue    depthStencil;
    VkSubpassContents               contents);              VkRenderPass           renderPass;          }
                                                            VkFramebuffer          framebuffer;         typedef enum VkSubpassContents {
                                                            VkRect2D               renderArea;              VK_SUBPASS_CONTENTS_INLINE,
                                                            uint32_t               clearValueCount;         VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS,
                                                            const VkClearValue*    pClearValues;        }
                                                        }
                                                        typedef union VkClearColorValue {               typedef struct VkClearDepthStencilValue {
                                                            float       float32[4];                         float       depth;
                                                            int32_t     int32[4];                           uint32_t    stencil;
                                                            uint32_t    uint32[4];                      }
                                                        }

void vkCmdEndRenderPass(VkCommandBuffer  commandBuffer);            typedef struct VkRenderPassAttachmentBeginInfo {    typedef struct VkInputAttachmentAspectReference {
                                                                        VkStructureType       sType;                        uint32_t              subpass;
void vkDestroyRenderPass(                                               const void*           pNext;                        uint32_t              inputAttachmentIndex;
    VkDevice                       device,                              uint32_t              attachmentCount;              VkImageAspectFlagBits aspectMask;
    VkRenderPass                   renderPass,                          const VkImageView*    pAttachments;             }
    const VkAllocationCallbacks*   pAllocator);                     }
                                                                    typedef struct VkRenderPassInputAttachmentAspectCreateInfo {
void vkCmdNextSubpass(                                                  VkStructureType                            sType;
    VkCommandBuffer                commandBuffer,                       const void*                                pNext;
    VkSubpassContents              contents);                           uint32_t                                   aspectReferenceCount;
                                                                        const VkInputAttachmentAspectReference*    pAspectReferences;
                                                                    }

VkSubpassBeginInfo
VkSubpassContents
VkSubpassDependency
VkSubpassDependency2
VkSubpassDescription
VkSubpassDescription2
VkSubpassDescriptionDepthStencilResolve
VkSubpassDescriptionFlagBits
VkSubpassEndInfo


===== Appendix

typedef struct VkPhysicalDeviceFeatures {               typedef struct VkPhysicalDeviceLimits {
    VkBool32 robustBufferAccess;                            uint32_t              maxImageDimension1D;
    VkBool32 fullDrawIndexUint32;                           uint32_t              maxImageDimension2D;
    VkBool32 imageCubeArray;                                uint32_t              maxImageDimension3D;
    VkBool32 independentBlend;                              uint32_t              maxImageDimensionCube;
    VkBool32 geometryShader;                                uint32_t              maxImageArrayLayers;
    VkBool32 tessellationShader;                            uint32_t              maxTexelBufferElements;
    VkBool32 sampleRateShading;                             uint32_t              maxUniformBufferRange;
    VkBool32 dualSrcBlend;                                  uint32_t              maxStorageBufferRange;
    VkBool32 logicOp;                                       uint32_t              maxPushConstantsSize;
    VkBool32 multiDrawIndirect;                             uint32_t              maxMemoryAllocationCount;
    VkBool32 drawIndirectFirstInstance;                     uint32_t              maxSamplerAllocationCount;
    VkBool32 depthClamp;                                    VkDeviceSize          bufferImageGranularity;
    VkBool32 depthBiasClamp;                                VkDeviceSize          sparseAddressSpaceSize;
    VkBool32 fillModeNonSolid;                              uint32_t              maxBoundDescriptorSets;
    VkBool32 depthBounds;                                   uint32_t              maxPerStageDescriptorSamplers;
    VkBool32 wideLines;                                     uint32_t              maxPerStageDescriptorUniformBuffers;
    VkBool32 largePoints;                                   uint32_t              maxPerStageDescriptorStorageBuffers;
    VkBool32 alphaToOne;                                    uint32_t              maxPerStageDescriptorSampledImages;
    VkBool32 multiViewport;                                 uint32_t              maxPerStageDescriptorStorageImages;
    VkBool32 samplerAnisotropy;                             uint32_t              maxPerStageDescriptorInputAttachments;
    VkBool32 textureCompressionETC2;                        uint32_t              maxPerStageResources;
    VkBool32 textureCompressionASTC_LDR;                    uint32_t              maxDescriptorSetSamplers;
    VkBool32 textureCompressionBC;                          uint32_t              maxDescriptorSetUniformBuffers;
    VkBool32 occlusionQueryPrecise;                         uint32_t              maxDescriptorSetUniformBuffersDynamic;
    VkBool32 pipelineStatisticsQuery;                       uint32_t              maxDescriptorSetStorageBuffers;
    VkBool32 vertexPipelineStoresAndAtomics;                uint32_t              maxDescriptorSetStorageBuffersDynamic;
    VkBool32 fragmentStoresAndAtomics;                      uint32_t              maxDescriptorSetSampledImages;
    VkBool32 shaderTessellationAndGeometryPointSize;        uint32_t              maxDescriptorSetStorageImages;
    VkBool32 shaderImageGatherExtended;                     uint32_t              maxDescriptorSetInputAttachments;
    VkBool32 shaderStorageImageExtendedFormats;             uint32_t              maxVertexInputAttributes;
    VkBool32 shaderStorageImageMultisample;                 uint32_t              maxVertexInputBindings;
    VkBool32 shaderStorageImageReadWithoutFormat;           uint32_t              maxVertexInputAttributeOffset;
    VkBool32 shaderStorageImageWriteWithoutFormat;          uint32_t              maxVertexInputBindingStride;
    VkBool32 shaderUniformBufferArrayDynamicIndexing;       uint32_t              maxVertexOutputComponents;
    VkBool32 shaderSampledImageArrayDynamicIndexing;        uint32_t              maxTessellationGenerationLevel;
    VkBool32 shaderStorageBufferArrayDynamicIndexing;       uint32_t              maxTessellationPatchSize;
    VkBool32 shaderStorageImageArrayDynamicIndexing;        uint32_t              maxTessellationControlPerVertexInputComponents;
    VkBool32 shaderClipDistance;                            uint32_t              maxTessellationControlPerVertexOutputComponents;
    VkBool32 shaderCullDistance;                            uint32_t              maxTessellationControlPerPatchOutputComponents;
    VkBool32 shaderFloat64;                                 uint32_t              maxTessellationControlTotalOutputComponents;
    VkBool32 shaderInt64;                                   uint32_t              maxTessellationEvaluationInputComponents;
    VkBool32 shaderInt16;                                   uint32_t              maxTessellationEvaluationOutputComponents;
    VkBool32 shaderResourceResidency;                       uint32_t              maxGeometryShaderInvocations;
    VkBool32 shaderResourceMinLod;                          uint32_t              maxGeometryInputComponents;
    VkBool32 sparseBinding;                                 uint32_t              maxGeometryOutputComponents;
    VkBool32 sparseResidencyBuffer;                         uint32_t              maxGeometryOutputVertices;
    VkBool32 sparseResidencyImage2D;                        uint32_t              maxGeometryTotalOutputComponents;
    VkBool32 sparseResidencyImage3D;                        uint32_t              maxFragmentInputComponents;
    VkBool32 sparseResidency2Samples;                       uint32_t              maxFragmentOutputAttachments;
    VkBool32 sparseResidency4Samples;                       uint32_t              maxFragmentDualSrcAttachments;
    VkBool32 sparseResidency8Samples;                       uint32_t              maxFragmentCombinedOutputResources;
    VkBool32 sparseResidency16Samples;                      uint32_t              maxComputeSharedMemorySize;
    VkBool32 sparseResidencyAliased;                        uint32_t              maxComputeWorkGroupCount[3];
    VkBool32 variableMultisampleRate;                       uint32_t              maxComputeWorkGroupInvocations;
    VkBool32 inheritedQueries;                              uint32_t              maxComputeWorkGroupSize[3];
}                                                           uint32_t              subPixelPrecisionBits;
                                                            uint32_t              subTexelPrecisionBits;
typedef enum VkImageAspectFlagBits {                        uint32_t              mipmapPrecisionBits;
    VK_IMAGE_ASPECT_COLOR_BIT,                              uint32_t              maxDrawIndexedIndexValue;
    VK_IMAGE_ASPECT_DEPTH_BIT,                              uint32_t              maxDrawIndirectCount;
    VK_IMAGE_ASPECT_STENCIL_BIT,                            float                 maxSamplerLodBias;
    VK_IMAGE_ASPECT_METADATA_BIT,                           float                 maxSamplerAnisotropy;
    VK_IMAGE_ASPECT_PLANE_0_BIT,                            uint32_t              maxViewports;
    VK_IMAGE_ASPECT_PLANE_1_BIT,                            uint32_t              maxViewportDimensions[2];
    VK_IMAGE_ASPECT_PLANE_2_BIT,                            float                 viewportBoundsRange[2];
}                                                           uint32_t              viewportSubPixelBits;
                                                            size_t                minMemoryMapAlignment;
                                                            VkDeviceSize          minTexelBufferOffsetAlignment;
                                                            VkDeviceSize          minUniformBufferOffsetAlignment;
                                                            VkDeviceSize          minStorageBufferOffsetAlignment;
                                                            int32_t               minTexelOffset;
                                                            uint32_t              maxTexelOffset;
                                                            int32_t               minTexelGatherOffset;
                                                            uint32_t              maxTexelGatherOffset;
                                                            float                 minInterpolationOffset;
                                                            float                 maxInterpolationOffset;
                                                            uint32_t              subPixelInterpolationOffsetBits;
                                                            uint32_t              maxFramebufferWidth;
                                                            uint32_t              maxFramebufferHeight;
                                                            uint32_t              maxFramebufferLayers;
                                                            VkSampleCountFlagBits framebufferColorSampleCounts;
                                                            VkSampleCountFlagBits framebufferDepthSampleCounts;
                                                            VkSampleCountFlagBits framebufferStencilSampleCounts;
                                                            VkSampleCountFlagBits framebufferNoAttachmentsSampleCounts;
                                                            uint32_t              maxColorAttachments;
                                                            VkSampleCountFlagBits sampledImageColorSampleCounts;
                                                            VkSampleCountFlagBits sampledImageIntegerSampleCounts;
                                                            VkSampleCountFlagBits sampledImageDepthSampleCounts;
                                                            VkSampleCountFlagBits sampledImageStencilSampleCounts;
                                                            VkSampleCountFlagBits storageImageSampleCounts;
                                                            uint32_t              maxSampleMaskWords;
                                                            VkBool32              timestampComputeAndGraphics;
                                                            float                 timestampPeriod;
                                                            uint32_t              maxClipDistances;
                                                            uint32_t              maxCullDistances;
                                                            uint32_t              maxCombinedClipAndCullDistances;
                                                            uint32_t              discreteQueuePriorities;
                                                            float                 pointSizeRange[2];
                                                            float                 lineWidthRange[2];
                                                            float                 pointSizeGranularity;
                                                            float                 lineWidthGranularity;
                                                            VkBool32              strictLines;
                                                            VkBool32              standardSampleLocations;
                                                            VkDeviceSize          optimalBufferCopyOffsetAlignment;
                                                            VkDeviceSize          optimalBufferCopyRowPitchAlignment;
                                                            VkDeviceSize          nonCoherentAtomSize;
                                                        }

typedef enum VkFormatFeatureFlags {
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT,
    VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT,
    VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT,
    VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT,
    VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT,
    VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT,
    VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT,
    VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT,
    VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT,
    VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT,
    VK_FORMAT_FEATURE_BLIT_SRC_BIT,
    VK_FORMAT_FEATURE_BLIT_DST_BIT,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT,
    VK_FORMAT_FEATURE_TRANSFER_SRC_BIT,
    VK_FORMAT_FEATURE_TRANSFER_DST_BIT,
    VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT,
    VK_FORMAT_FEATURE_DISJOINT_BIT,
    VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG,
    VK_FORMAT_FEATURE_VIDEO_DECODE_OUTPUT_BIT_KHR,
    VK_FORMAT_FEATURE_VIDEO_DECODE_DPB_BIT_KHR,
    VK_FORMAT_FEATURE_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR,
    VK_FORMAT_FEATURE_FRAGMENT_DENSITY_MAP_BIT_EXT,
    VK_FORMAT_FEATURE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR,
    VK_FORMAT_FEATURE_VIDEO_ENCODE_INPUT_BIT_KHR,
    VK_FORMAT_FEATURE_VIDEO_ENCODE_DPB_BIT_KHR,
}
