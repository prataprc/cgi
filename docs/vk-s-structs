Simple types
------------

VkExtent2D VkExtent3D { width, height, depth },
VkOffset2D VkOffset3D { x, y, z },
VkRect2D { VkOffset2D, VkExtent2D }

typedef uint64_t VkDeviceSize;

typedef struct VkMemoryType {
    VkMemoryPropertyFlags    propertyFlags;                                                     typedef enum VkMemoryPropertyFlags {
    uint32_t                 heapIndex;                                                             VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT,
}                                                                                                   VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT,
                                                                                                    VK_MEMORY_PROPERTY_HOST_COHERENT_BIT,
typedef struct VkMemoryHeap {                   typedef enum VkMemoryHeapFlagBits {                 VK_MEMORY_PROPERTY_HOST_CACHED_BIT,
    VkDeviceSize         size;                      VK_MEMORY_HEAP_DEVICE_LOCAL_BIT,                VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT,
    VkMemoryHeapFlags    flags;                     VK_MEMORY_HEAP_MULTI_INSTANCE_BIT,              VK_MEMORY_PROPERTY_PROTECTED_BIT,
}                                               }                                                   VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD,
                                                                                                    VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD,
typedef enum VkPhysicalDeviceType {                                                             }
    VK_PHYSICAL_DEVICE_TYPE_OTHER,
    VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU,
    VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU,
    VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU,
    VK_PHYSICAL_DEVICE_TYPE_CPU,
}

VkFormat:
    RGBA/E/DS/X
    UNORM/SNORM/USCALED/SSCALED/UINT/SINT/UFLOAT/SFLOAT
    PACK8/PACK16/2PACK16/3PACK16/4PACK16/PACK32/BLOCK
    BC1/BC2/BC3/BC4/BC5/BC6H/BC7/ETC2/EAC/ASTC/PVRTC1/PVRTC2
    2BPP/4BPP/SRGB, 2PLANE/3PLANE, 422/420/444

Image
    Format -> Size, DataType, Plane, Block, Aspects, Properties(Phydev)
    ImageType -> 1D, 2D, 3D
    ImageTiling -> Linear, Optimal
    ImageDimensions -> Extent
    ImageAspects -> Color, Depth, Stencil, Metadata, Plane0, Plane1, Plane2, MemoryPlane0, MemoryPlane1, MemoryPlane2,
    ImageLayout ->
    ImageUsage -> sampled, storage, tx_source, tx_dest, color_attach, depth_stencil_attach, trans_attch, input_attach
    ImageFormatProperties -> max_extent, max_mip_levels, max_array_layers, sample_counts, max_resource_size


Dispatchable and Non-Dispatchable Handles
-----------------------------------------

VkInstance
    +-> VkPhysicalDevice
    |   +-> VkDevice <- VkDeviceCreateInfo
    |       +-> VkQueue
    |       +-> VkSwapchain <- VkSwapchainCreateInfoKHR
    |       +-> VkCommandPool <- VkCommandPoolCreateInfo
    |       +-> VkCommandBuffer <- VkCommandBufferAllocateInfo
    |       +-> VkDeviceMemory <- VkMemoryAllocateInfo
    |       +-> VkBuffer <- VkBufferCreateInfo
    |       +-> VkBufferView <- VkBufferViewCreateInfo
    |       +-> VkImage <- VkImageCreateInfo
    |       +-> VkImageView <- VkImageViewCreateInfo
    |       +-> VkSampler <- VkSamplerCreateInfo
    |       +-> VkQueryPool <- VkQueryPoolCreateInfo
    |       +-> VkShaderModule <- VkShaderModuleCreateInfo
    |       +-> VkPipeline <- VkPipelineCache, VkGraphicsPipelineCreateInfo
    |       +-> VkPipeline <- VkPipelineCache, VkComputePipelineCreateInfo
    |       +-> VkPipelineLayout <- VkPipelineLayoutCreateInfo
    |       +-> VkPipelineCache <- VkPipelineCacheCreateInfo
    |       +-> VkEvent <- VkEventCreateInfo
    |       +-> VkFence <- VkFenceCreateInfo
    |       +-> VkSemaphore <- VkSemaphoreCreateInfo
    |       +-> VkRenderPass <- VkRenderPassCreateInfo
    |       +-> VkFramebuffer <- VkFramebufferCreateInfo
    |       +-> VkDescriptorPool <- VkDescriptorPoolCreateInfo
    |       +-> VkDescriptorSet <- VkDescriptorSetAllocateInfo
    |       +-> VkDescriptorSetLayout <- VkDescriptorSetLayoutCreateInfo
    |       +-> VkDescriptorUpdateTemplate <- VkDescriptorUpdateTemplateCreateInfo
    +-> VkSurface
    +-> VkDisplay
    +-> VkDisplayMode

==== VkInstance

* vkGetInstanceProcAddr
* Query Physical Devices and Device Groups
* Query Layers and Extensions

VkResult vkCreateInstance(
    const VkInstanceCreateInfo*   pCreateInfo,      typedef struct VkInstanceCreateInfo {                       typedef struct VkApplicationInfo {
    const VkAllocationCallbacks*  pAllocator,           const VkApplicationInfo*    pApplicationInfo;               VkStructureType    sType;
    VkInstance*                   pInstance);           uint32_t                    enabledLayerCount;              const void*        pNext;
                                                        const char* const*          ppEnabledLayerNames;            const char*        pApplicationName;
 PFN_vkVoidFunction vkGetInstanceProcAddr(              uint32_t                    enabledExtensionCount;          uint32_t           applicationVersion;
     VkInstance    instance,                            const char* const*          ppEnabledExtensionNames;        const char*        pEngineName;
     const char*   pName);                          }                                                               uint32_t           engineVersion; 
                                                                                                                    uint32_t           apiVersion;
 VkResult vkEnumeratePhysicalDevices(                                                                           }
     VkInstance          instance,
     uint32_t*           pPhysicalDeviceCount,
     VkPhysicalDevice*   pPhysicalDevices);

 VkResult vkEnumerateInstanceLayerProperties(        typedef struct VkLayerProperties {
     uint32_t*           pPropertyCount,                 char        layerName[VK_MAX_EXTENSION_NAME_SIZE];
     VkLayerProperties*  pProperties);                   uint32_t    specVersion;
                                                         uint32_t    implementationVersion;
                                                         char        description[VK_MAX_DESCRIPTION_SIZE];
                                                     }
 VkResult vkEnumerateInstanceExtensionProperties(    typedef struct VkExtensionProperties {
     const char*               pLayerName,               char        extensionName[VK_MAX_EXTENSION_NAME_SIZE];
     uint32_t*                 pPropertyCount,           uint32_t    specVersion;
     VkExtensionProperties*    pProperties);         }


==== VkPhysicalDevice

* Vulkan separates the concept of physical and logical devices.
* Layers and extensions.
* Display, DisplayMode, DisplayPlane, DisplayCapabilities, DisplayProperties.

VkResult vkEnumerateDeviceExtensionProperties(
    VkPhysicalDevice        physicalDevice,
    const char*             pLayerName,
    uint32_t*               pPropertyCount,
    VkExtensionProperties*  pProperties);
VkResult vkEnumerateDeviceLayerProperties(
    VkPhysicalDevice        physicalDevice,
    uint32_t*               pPropertyCount,
    VkLayerProperties*      pProperties);

void vkGetPhysicalDeviceFeatures(                               typedef struct VkPhysicalDeviceProperties {
    VkPhysicalDevice            physicalDevice,                     uint32_t                          apiVersion;
    VkPhysicalDeviceFeatures*   pFeatures);                         uint32_t                          driverVersion;
void vkGetPhysicalDeviceFeatures2KHR(                               uint32_t                          vendorID;
    VkPhysicalDevice            physicalDevice,                     uint32_t                          deviceID;
    VkPhysicalDeviceFeatures2*  pFeatures);                         VkPhysicalDeviceType              deviceType;
void vkGetPhysicalDeviceProperties(                                 char                              deviceName[VK_MAX_PHYSICAL_DEVICE_NAME_SIZE];
    VkPhysicalDevice            physicalDevice,                     uint8_t                           pipelineCacheUUID[VK_UUID_SIZE];
    VkPhysicalDeviceProperties* pProperties);                       VkPhysicalDeviceLimits            limits;
                                                                    VkPhysicalDeviceSparseProperties  sparseProperties;
                                                                }
void vkGetPhysicalDeviceMemoryProperties(                       typedef struct VkPhysicalDeviceMemoryProperties {           typedef enum VkQueueFlags {
    VkPhysicalDevice                    physicalDevice,             uint32_t        memoryTypeCount;                            VK_QUEUE_GRAPHICS_BIT,
    VkPhysicalDeviceMemoryProperties*   pMemoryProperties);         VkMemoryType    memoryTypes[VK_MAX_MEMORY_TYPES];           VK_QUEUE_COMPUTE_BIT,
                                                                    uint32_t        memoryHeapCount;                            VK_QUEUE_TRANSFER_BIT,
                                                                    VkMemoryHeap    memoryHeaps[VK_MAX_MEMORY_HEAPS];           VK_QUEUE_SPARSE_BINDING_BIT,
                                                                }                                                               VK_QUEUE_PROTECTED_BIT,
                                                                                                                                VK_QUEUE_VIDEO_DECODE_BIT_KHR,
void vkGetPhysicalDeviceQueueFamilyProperties(                  typedef struct VkQueueFamilyProperties {                        VK_QUEUE_VIDEO_ENCODE_BIT_KHR,
    VkPhysicalDevice            physicalDevice,                     VkQueueFlags    queueFlags;                             }
    uint32_t*                   pQueueFamilyPropertyCount,          uint32_t        queueCount;
    VkQueueFamilyProperties*    pQueueFamilyProperties);            uint32_t        timestampValidBits;
                                                                    VkExtent3D      minImageTransferGranularity;
                                                                }

void vkGetPhysicalDeviceFormatProperties(                       typedef struct VkFormatProperties {
    VkPhysicalDevice        physicalDevice,                         VkFormatFeatureFlags    linearTilingFeatures;
    VkFormat                format,                                 VkFormatFeatureFlags    optimalTilingFeatures;
    VkFormatProperties*     pFormatProperties);                     VkFormatFeatureFlags    bufferFeatures;
                                                                }

// TODO: Query ImageFormatProperties.

==== VkSurface

* Surface is created using Instance and platform specific surface constructor and parameters.
* Surface can be created directly from display (monitor) bypassing WSI
* Headless surface can be created, which is essentially a no-op.

vkGetPhysicalDeviceSurfaceSupportKHR (per queue-family)


vkGetPhysicalDeviceSurfacePresentModesKHR               vkGetPhysicalDeviceSurfaceCapabilitiesKHR,
typedef enum VkPresentModeKHR {                         typedef struct VkSurfaceCapabilitiesKHR {                  typedef enum VkSurfaceTransformFlagsKHR {
    VK_PRESENT_MODE_IMMEDIATE_KHR,                          uint32_t                    minImageCount;                 VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR,
    VK_PRESENT_MODE_MAILBOX_KHR,                            uint32_t                    maxImageCount;                 VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR,
    VK_PRESENT_MODE_FIFO_KHR,                               VkExtent2D                  currentExtent;                 VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR,
    VK_PRESENT_MODE_FIFO_RELAXED_KHR,                       VkExtent2D                  minImageExtent;                VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR,
    VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR,              VkExtent2D                  maxImageExtent;                VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR,
    VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR,          uint32_t                    maxImageArrayLayers;           VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR,
};                                                          VkSurfaceTransformFlagsKHR  supportedTransforms;           VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR,
                                                            VkSurfaceTransformFlagsKHR  currentTransform;              VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR,
vkGetPhysicalDeviceSurfaceFormatsKHR                        VkCompositeAlphaFlagsKHR    supportedCompositeAlpha;       VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR,
typedef struct VkSurfaceFormatKHR {                         VkImageUsageFlags           supportedUsageFlags;       }
    VkFormat           format;                          }
    VkColorSpaceKHR    colorSpace;                      typedef enum VkCompositeAlphaFlagBitsKHR {                 typedef enum VkImageUsageFlags {
}                                                           VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR,                         VK_IMAGE_USAGE_TRANSFER_SRC_BIT,
typedef enum VkColorSpaceKHR {                              VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR,                 VK_IMAGE_USAGE_TRANSFER_DST_BIT,
    VK_COLOR_SPACE_SRGB_NONLINEAR_KHR,                      VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR,                VK_IMAGE_USAGE_SAMPLED_BIT,
    VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT,                VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR,                        VK_IMAGE_USAGE_STORAGE_BIT,
    VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT,            }                                                              VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT,         (FB)
    VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT,                                                                              VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, (FB)
    VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT,                                                                               VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT,
    VK_COLOR_SPACE_BT709_LINEAR_EXT,                                                                                   VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT,         (FB)
    VK_COLOR_SPACE_BT709_NONLINEAR_EXT,                                                                                VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR,
    VK_COLOR_SPACE_BT2020_LINEAR_EXT,                                                                                  VK_IMAGE_USAGE_VIDEO_DECODE_SRC_BIT_KHR,
    VK_COLOR_SPACE_HDR10_ST2084_EXT,                                                                                   VK_IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR,
    VK_COLOR_SPACE_DOLBYVISION_EXT,                                                                                    VK_IMAGE_USAGE_VIDEO_ENCODE_DST_BIT_KHR,
    VK_COLOR_SPACE_HDR10_HLG_EXT,                                                                                      VK_IMAGE_USAGE_VIDEO_ENCODE_SRC_BIT_KHR,
    VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT,                                                                                VK_IMAGE_USAGE_VIDEO_ENCODE_DPB_BIT_KHR,
    VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT,                                                                             VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV,
    VK_COLOR_SPACE_PASS_THROUGH_EXT,                                                                                   VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT,
    VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT,                                                                    }
    VK_COLOR_SPACE_DISPLAY_NATIVE_AMD,
}


==== VkSwapchain

VkResult vkCreateSwapchainKHR(
    VkDevice                                    device,
    const VkSwapchainCreateInfoKHR*             pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkSwapchainKHR*                             pSwapchain);

typedef struct VkSwapchainCreateInfoKHR {                                       typedef struct VkImageCreateInfo {
    VkStructureType                  sType;                                       * VkImageCreateFlags       flags;                 typedef enum VkImageCreateFlagBits {
    const void*                      pNext;                                       * VkImageType              imageType;                 VK_IMAGE_CREATE_SPARSE_BINDING_BIT,
    VkSwapchainCreateFlagsKHR        flags;                                         VkFormat                 format;                    VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT,
    VkSurfaceKHR                     surface;                                       VkExtent3D               extent;                    VK_IMAGE_CREATE_SPARSE_ALIASED_BIT,
    uint32_t                         minImageCount;                               * uint32_t                 mipLevels;                 VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT,
                                                                                    uint32_t                 arrayLayers;               VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT,
    VkSurfaceTransformFlagBitsKHR    preTransform;    (VkSurface)                 * VkSampleCountFlagBits    samples;                   VK_IMAGE_CREATE_ALIAS_BIT,
    VkCompositeAlphaFlagBitsKHR      compositeAlpha;  (VkSurface)                 * VkImageTiling            tiling;                    VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT,
    VkColorSpaceKHR                  imageColorSpace; (VkSurface)                   VkImageUsageFlags        usage;                     VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT,
    VkPresentModeKHR                 presentMode;     (VkSurface)                   VkSharingMode            sharingMode;               VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT,
                                                                                    uint32_t                 queueFamilyIndexCount;     VK_IMAGE_CREATE_EXTENDED_USAGE_BIT,
    VkFormat                         imageFormat;     (VkSurface, VkImage)          const uint32_t*          pQueueFamilyIndices;       VK_IMAGE_CREATE_PROTECTED_BIT,
    VkExtent2D                       imageExtent;     (VkSurface, VkImage)        * VkImageLayout            initialLayout;             VK_IMAGE_CREATE_DISJOINT_BIT,
    uint32_t                         imageArrayLayers;(VkSurface, VkImage)      } VkImageCreateInfo;                                    VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR,
    VkImageUsageFlags                imageUsage;      (VkSurface, VkImage)                                                              VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR,
    VkSharingMode                    imageSharingMode;      (VkImage)           typedef enum VkSharingMode {                            VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR,
    uint32_t                         queueFamilyIndexCount; (VkImage)               VK_SHARING_MODE_EXCLUSIVE = 0,                      VK_IMAGE_CREATE_EXTENDED_USAGE_BIT_KHR,
    const uint32_t*                  pQueueFamilyIndices;   (VkImage)               VK_SHARING_MODE_CONCURRENT = 1,                     VK_IMAGE_CREATE_DISJOINT_BIT_KHR,
                                                                                }                                                       VK_IMAGE_CREATE_ALIAS_BIT_KHR,
    VkBool32                         clipped;                                                                                       }
    VkSwapchainKHR                   oldSwapchain;                              typedef enum VkImageType {
}                                                                                   VK_IMAGE_TYPE_1D,                               typedef enum VkSampleCountFlagBits {
typedef enum VkSwapchainCreateFlagsKHR {                                            VK_IMAGE_TYPE_2D,                                   VK_SAMPLE_COUNT_1_BIT,
    VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR,                        VK_IMAGE_TYPE_3D,                                   VK_SAMPLE_COUNT_2_BIT,
    VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR,                                      }                                                       VK_SAMPLE_COUNT_4_BIT,
    VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR,                                 typedef enum VkImageTiling {                            VK_SAMPLE_COUNT_8_BIT,
}                                                                                   VK_IMAGE_TILING_OPTIMAL,                            VK_SAMPLE_COUNT_16_BIT, 
                                                                                    VK_IMAGE_TILING_LINEAR,                             VK_SAMPLE_COUNT_32_BIT,
typedef struct VkDisplayModeParametersKHR {                                     }                                                       VK_SAMPLE_COUNT_64_BIT,
    VkExtent2D    visibleRegion;                                                                                                    }
    uint32_t      refreshRate;
}

VkResult vkAcquireNextImageKHR(             typedef struct VkPresentInfoKHR {                       typedef enum VkImageLayout {
    VkDevice        device,                     VkStructureType          sType;                         VK_IMAGE_LAYOUT_UNDEFINED,
    VkSwapchainKHR  swapchain,                  const void*              pNext;                         VK_IMAGE_LAYOUT_GENERAL,
    uint64_t        timeout,                    uint32_t                 waitSemaphoreCount;            VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL,
    VkSemaphore     semaphore,                  const VkSemaphore*       pWaitSemaphores;               VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL,
    VkFence         fence,                      uint32_t                 swapchainCount;                VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL,
    uint32_t*       pImageIndex);               const VkSwapchainKHR*    pSwapchains;                   VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL,
                                                const uint32_t*          pImageIndices;                 VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,
VkResult vkGetSwapchainImagesKHR(               VkResult*                pResults;                      VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
    VkDevice        device,                 }                                                           VK_IMAGE_LAYOUT_PREINITIALIZED,
    VkSwapchainKHR  swapchain,              Extending VkBindImageMemoryInfoKHR.pNext                    VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL,
    uint32_t*       pSwapchainImageCount,   typedef struct VkBindImageMemorySwapchainInfoKHR {          VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL,
    VkImage*        pSwapchainImages);          VkStructureType    sType;                               VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMA,
                                                const void*        pNext;                               VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL,
                                                VkSwapchainKHR     swapchain;                           VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL,
                                                uint32_t           imageIndex;                          VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL,
                                            }                                                           VK_IMAGE_LAYOUT_PRESENT_SRC_KHR,
                                            Extending VkImageCreateInfoKHR.pNext                        VK_IMAGE_LAYOUT_VIDEO_DECODE_DST_KHR,
                                            typedef struct VkImageSwapchainCreateInfoKHR {              VK_IMAGE_LAYOUT_VIDEO_DECODE_SRC_KHR,
                                                VkStructureType    sType;                               VK_IMAGE_LAYOUT_VIDEO_DECODE_DPB_KHR,
                                                const void*        pNext;                               VK_IMAGE_LAYOUT_VIDEO_ENCODE_DST_KHR,
                                                VkSwapchainKHR     swapchain;                           VK_IMAGE_LAYOUT_VIDEO_ENCODE_SRC_KHR,
                                            }                                                           VK_IMAGE_LAYOUT_VIDEO_ENCODE_DPB_KHR,
                                                                                                        VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR,
                                                                                                        VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL_KHR,
                                                                                                        VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL_KHR,
                                                                                                    }


==== VkImage


==== VkDevice

typedef struct VkDeviceCreateInfo {
    VkStructureType                    sType;
    const void*                        pNext; // long list of optional parameters.
    VkDeviceCreateFlags                flags; // reserved
    uint32_t                           queueCreateInfoCount;
    const VkDeviceQueueCreateInfo*     pQueueCreateInfos;
    uint32_t                           enabledLayerCount;
    const char* const*                 ppEnabledLayerNames;
    uint32_t                           enabledExtensionCount;
    const char* const*                 ppEnabledExtensionNames;
    const VkPhysicalDeviceFeatures*    pEnabledFeatures;
}
typedef struct VkDeviceQueueCreateInfo {                typedef enum VkDeviceQueueCreateFlagBits {
    VkStructureType             sType;                      VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT = 0x00000001,
    const void*                 pNext;                  }
    VkDeviceQueueCreateFlags    flags;
    uint32_t                    queueFamilyIndex;
    uint32_t                    queueCount;
    const float*                pQueuePriorities;
}


typedef struct VkCommandPoolCreateInfo {            typedef enum VkCommandPoolCreateFlagBits {
    VkStructureType             sType;                  VK_COMMAND_POOL_CREATE_TRANSIENT_BIT,
    const void*                 pNext;                  VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT,
    VkCommandPoolCreateFlags    flags;                  VK_COMMAND_POOL_CREATE_PROTECTED_BIT,
    uint32_t                    queueFamilyIndex;   }
}


typedef struct VkCommandBufferAllocateInfo {        typedef enum VkCommandBufferLevel {
    VkStructureType         sType;                      VK_COMMAND_BUFFER_LEVEL_PRIMARY,
    const void*             pNext;                      VK_COMMAND_BUFFER_LEVEL_SECONDARY,
    VkCommandPool           commandPool;            }
    VkCommandBufferLevel    level;
    uint32_t                commandBufferCount;
}





typedef struct VkPhysicalDeviceFeatures {               typedef struct VkPhysicalDeviceLimits {
    VkBool32 robustBufferAccess;                            uint32_t              maxImageDimension1D;
    VkBool32 fullDrawIndexUint32;                           uint32_t              maxImageDimension2D;
    VkBool32 imageCubeArray;                                uint32_t              maxImageDimension3D;
    VkBool32 independentBlend;                              uint32_t              maxImageDimensionCube;
    VkBool32 geometryShader;                                uint32_t              maxImageArrayLayers;
    VkBool32 tessellationShader;                            uint32_t              maxTexelBufferElements;
    VkBool32 sampleRateShading;                             uint32_t              maxUniformBufferRange;
    VkBool32 dualSrcBlend;                                  uint32_t              maxStorageBufferRange;
    VkBool32 logicOp;                                       uint32_t              maxPushConstantsSize;
    VkBool32 multiDrawIndirect;                             uint32_t              maxMemoryAllocationCount;
    VkBool32 drawIndirectFirstInstance;                     uint32_t              maxSamplerAllocationCount;
    VkBool32 depthClamp;                                    VkDeviceSize          bufferImageGranularity;
    VkBool32 depthBiasClamp;                                VkDeviceSize          sparseAddressSpaceSize;
    VkBool32 fillModeNonSolid;                              uint32_t              maxBoundDescriptorSets;
    VkBool32 depthBounds;                                   uint32_t              maxPerStageDescriptorSamplers;
    VkBool32 wideLines;                                     uint32_t              maxPerStageDescriptorUniformBuffers;
    VkBool32 largePoints;                                   uint32_t              maxPerStageDescriptorStorageBuffers;
    VkBool32 alphaToOne;                                    uint32_t              maxPerStageDescriptorSampledImages;
    VkBool32 multiViewport;                                 uint32_t              maxPerStageDescriptorStorageImages;
    VkBool32 samplerAnisotropy;                             uint32_t              maxPerStageDescriptorInputAttachments;
    VkBool32 textureCompressionETC2;                        uint32_t              maxPerStageResources;
    VkBool32 textureCompressionASTC_LDR;                    uint32_t              maxDescriptorSetSamplers;
    VkBool32 textureCompressionBC;                          uint32_t              maxDescriptorSetUniformBuffers;
    VkBool32 occlusionQueryPrecise;                         uint32_t              maxDescriptorSetUniformBuffersDynamic;
    VkBool32 pipelineStatisticsQuery;                       uint32_t              maxDescriptorSetStorageBuffers;
    VkBool32 vertexPipelineStoresAndAtomics;                uint32_t              maxDescriptorSetStorageBuffersDynamic;
    VkBool32 fragmentStoresAndAtomics;                      uint32_t              maxDescriptorSetSampledImages;
    VkBool32 shaderTessellationAndGeometryPointSize;        uint32_t              maxDescriptorSetStorageImages;
    VkBool32 shaderImageGatherExtended;                     uint32_t              maxDescriptorSetInputAttachments;
    VkBool32 shaderStorageImageExtendedFormats;             uint32_t              maxVertexInputAttributes;
    VkBool32 shaderStorageImageMultisample;                 uint32_t              maxVertexInputBindings;
    VkBool32 shaderStorageImageReadWithoutFormat;           uint32_t              maxVertexInputAttributeOffset;
    VkBool32 shaderStorageImageWriteWithoutFormat;          uint32_t              maxVertexInputBindingStride;
    VkBool32 shaderUniformBufferArrayDynamicIndexing;       uint32_t              maxVertexOutputComponents;
    VkBool32 shaderSampledImageArrayDynamicIndexing;        uint32_t              maxTessellationGenerationLevel;
    VkBool32 shaderStorageBufferArrayDynamicIndexing;       uint32_t              maxTessellationPatchSize;
    VkBool32 shaderStorageImageArrayDynamicIndexing;        uint32_t              maxTessellationControlPerVertexInputComponents;
    VkBool32 shaderClipDistance;                            uint32_t              maxTessellationControlPerVertexOutputComponents;
    VkBool32 shaderCullDistance;                            uint32_t              maxTessellationControlPerPatchOutputComponents;
    VkBool32 shaderFloat64;                                 uint32_t              maxTessellationControlTotalOutputComponents;
    VkBool32 shaderInt64;                                   uint32_t              maxTessellationEvaluationInputComponents;
    VkBool32 shaderInt16;                                   uint32_t              maxTessellationEvaluationOutputComponents;
    VkBool32 shaderResourceResidency;                       uint32_t              maxGeometryShaderInvocations;
    VkBool32 shaderResourceMinLod;                          uint32_t              maxGeometryInputComponents;
    VkBool32 sparseBinding;                                 uint32_t              maxGeometryOutputComponents;
    VkBool32 sparseResidencyBuffer;                         uint32_t              maxGeometryOutputVertices;
    VkBool32 sparseResidencyImage2D;                        uint32_t              maxGeometryTotalOutputComponents;
    VkBool32 sparseResidencyImage3D;                        uint32_t              maxFragmentInputComponents;
    VkBool32 sparseResidency2Samples;                       uint32_t              maxFragmentOutputAttachments;
    VkBool32 sparseResidency4Samples;                       uint32_t              maxFragmentDualSrcAttachments;
    VkBool32 sparseResidency8Samples;                       uint32_t              maxFragmentCombinedOutputResources;
    VkBool32 sparseResidency16Samples;                      uint32_t              maxComputeSharedMemorySize;
    VkBool32 sparseResidencyAliased;                        uint32_t              maxComputeWorkGroupCount[3];
    VkBool32 variableMultisampleRate;                       uint32_t              maxComputeWorkGroupInvocations;
    VkBool32 inheritedQueries;                              uint32_t              maxComputeWorkGroupSize[3];
}                                                           uint32_t              subPixelPrecisionBits;
                                                            uint32_t              subTexelPrecisionBits;
                                                            uint32_t              mipmapPrecisionBits;
                                                            uint32_t              maxDrawIndexedIndexValue;
                                                            uint32_t              maxDrawIndirectCount;
                                                            float                 maxSamplerLodBias;
                                                            float                 maxSamplerAnisotropy;
                                                            uint32_t              maxViewports;
                                                            uint32_t              maxViewportDimensions[2];
                                                            float                 viewportBoundsRange[2];
                                                            uint32_t              viewportSubPixelBits;
                                                            size_t                minMemoryMapAlignment;
                                                            VkDeviceSize          minTexelBufferOffsetAlignment;
                                                            VkDeviceSize          minUniformBufferOffsetAlignment;
                                                            VkDeviceSize          minStorageBufferOffsetAlignment;
                                                            int32_t               minTexelOffset;
                                                            uint32_t              maxTexelOffset;
                                                            int32_t               minTexelGatherOffset;
                                                            uint32_t              maxTexelGatherOffset;
                                                            float                 minInterpolationOffset;
                                                            float                 maxInterpolationOffset;
                                                            uint32_t              subPixelInterpolationOffsetBits;
                                                            uint32_t              maxFramebufferWidth;
                                                            uint32_t              maxFramebufferHeight;
                                                            uint32_t              maxFramebufferLayers;
                                                            VkSampleCountFlags    framebufferColorSampleCounts;
                                                            VkSampleCountFlags    framebufferDepthSampleCounts;
                                                            VkSampleCountFlags    framebufferStencilSampleCounts;
                                                            VkSampleCountFlags    framebufferNoAttachmentsSampleCounts;
                                                            uint32_t              maxColorAttachments;
                                                            VkSampleCountFlags    sampledImageColorSampleCounts;
                                                            VkSampleCountFlags    sampledImageIntegerSampleCounts;
                                                            VkSampleCountFlags    sampledImageDepthSampleCounts;
                                                            VkSampleCountFlags    sampledImageStencilSampleCounts;
                                                            VkSampleCountFlags    storageImageSampleCounts;
                                                            uint32_t              maxSampleMaskWords;
                                                            VkBool32              timestampComputeAndGraphics;
                                                            float                 timestampPeriod;
                                                            uint32_t              maxClipDistances;
                                                            uint32_t              maxCullDistances;
                                                            uint32_t              maxCombinedClipAndCullDistances;
                                                            uint32_t              discreteQueuePriorities;
                                                            float                 pointSizeRange[2];
                                                            float                 lineWidthRange[2];
                                                            float                 pointSizeGranularity;
                                                            float                 lineWidthGranularity;
                                                            VkBool32              strictLines;
                                                            VkBool32              standardSampleLocations;
                                                            VkDeviceSize          optimalBufferCopyOffsetAlignment;
                                                            VkDeviceSize          optimalBufferCopyRowPitchAlignment;
                                                            VkDeviceSize          nonCoherentAtomSize;
                                                        }

typedef enum VkFormatFeatureFlags {
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT,
    VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT,
    VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT,
    VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT,
    VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT,
    VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT,
    VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT,
    VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT,
    VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT,
    VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT,
    VK_FORMAT_FEATURE_BLIT_SRC_BIT,
    VK_FORMAT_FEATURE_BLIT_DST_BIT,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT,
    VK_FORMAT_FEATURE_TRANSFER_SRC_BIT,
    VK_FORMAT_FEATURE_TRANSFER_DST_BIT,
    VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT,
    VK_FORMAT_FEATURE_DISJOINT_BIT,
    VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG,
    VK_FORMAT_FEATURE_VIDEO_DECODE_OUTPUT_BIT_KHR,
    VK_FORMAT_FEATURE_VIDEO_DECODE_DPB_BIT_KHR,
    VK_FORMAT_FEATURE_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR,
    VK_FORMAT_FEATURE_FRAGMENT_DENSITY_MAP_BIT_EXT,
    VK_FORMAT_FEATURE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR,
    VK_FORMAT_FEATURE_VIDEO_ENCODE_INPUT_BIT_KHR,
    VK_FORMAT_FEATURE_VIDEO_ENCODE_DPB_BIT_KHR,
}
